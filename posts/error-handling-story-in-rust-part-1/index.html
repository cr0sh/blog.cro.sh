<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rust의 에러 처리, Part 1 | Option::None</title>
<meta name="keywords" content="">
<meta name="description" content="Rust에서 어떻게 에러를 처리하고 복구하는지에 대해 실전 위주로 다뤄보고자 한다.">
<meta name="author" content="">
<link rel="canonical" href="http://blog.cro.sh/posts/error-handling-story-in-rust-part-1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://blog.cro.sh/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://blog.cro.sh/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://blog.cro.sh/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://blog.cro.sh/apple-touch-icon.png">
<link rel="mask-icon" href="http://blog.cro.sh/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="http://blog.cro.sh/css/allow-horizontal-highlight-scroll.css"><link rel="stylesheet" href="http://blog.cro.sh/css/small-page-heading.css"><meta property="og:title" content="Rust의 에러 처리, Part 1" />
<meta property="og:description" content="Rust에서 어떻게 에러를 처리하고 복구하는지에 대해 실전 위주로 다뤄보고자 한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.cro.sh/posts/error-handling-story-in-rust-part-1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-07T23:26:51+09:00" />
<meta property="article:modified_time" content="2023-01-07T23:26:51+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust의 에러 처리, Part 1"/>
<meta name="twitter:description" content="Rust에서 어떻게 에러를 처리하고 복구하는지에 대해 실전 위주로 다뤄보고자 한다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://blog.cro.sh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust의 에러 처리, Part 1",
      "item": "http://blog.cro.sh/posts/error-handling-story-in-rust-part-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust의 에러 처리, Part 1",
  "name": "Rust의 에러 처리, Part 1",
  "description": "Rust에서 어떻게 에러를 처리하고 복구하는지에 대해 실전 위주로 다뤄보고자 한다.\n",
  "keywords": [
    
  ],
  "articleBody": "Rust에서 어떻게 에러를 처리하고 복구하는지에 대해 실전 위주로 다뤄보고자 한다.\nenum Result Rust 에러 처리의 중추는 Result 열거형이다. 이 열거형의 정의는 매우 단순하다.\npub enum Result\u003cT, E\u003e { Ok(T), Err(E), } Result is a type that represents either success (Ok) or failure (Err).\n정의에서 볼 수 있듯이, 이는 ‘실패 가능한’ 값을 표현하는 데 주로 쓰인다. 성공 시 Ok를, 실패 시 Err를 가진다. 열거형이므로, 안에서 성공 또는 실패한 값을 꺼내려면 패턴 매칭을 사용해야 한다.\nlet x = Ok::\u003cu32, String\u003e(3); /* if x == 3 { } */ // 불가능하다. 실패했을 수도 있으니까. match x { Ok(x) =\u003e if x == 3 { /* ... */ } Err(e) =\u003e panic!(\"oops: {e}\") } 이를 사용하면 ‘실패 가능한 함수’를 표현할 수 있다.\nfn may_fail(a: u32, minus_b: u32) -\u003e Result\u003cu32, \u0026'static str\u003e{ if a \u003e minus_b { Ok(a - minus_b) } else { Err(\"would overflow!\") } } panic! 깜짝 놀라서 모든 것을 다 내던지고 싶을 때, panic!을 외치면 된다.\npanic!(\"망했어요\"): thread 'main' panicked at '망했어요', src/main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace panic!은 다른 언어의 exception과 동일하게 구현되어 있다. panic!을 ‘던지면’, 바깥의 핸들러가 ‘잡아줄’ 때 까지 계속해서 호출 스택을 더듬어 올라가게 된다. 그리고 그 기록이 backtrace로 남지만, RUST_BACKTRACE 환경 변수가 1이거나 full인 경우에만 표시되므로 주의가 필요하다. (full의 경우 1에서 쓸 데 없어서 숨겨진 일부 스택도 보여준다)\n이러한 기능에는 비용이 들기 때문에, 필요 없는 경우에는 Cargo profile에서 panic = \"abort\"를 주어 panic이 발생하는 그 즉시 프로그램이 종료되게 할 수도 있다. 관해서는 Cargo의 레퍼런스 문서를 참고하기 바란다.\n위의 may_fail을 panic!을 써서 다시 만들어 보면 이런 느낌일 것이다.\nfn may_fail(a: u32, minus_b: u32) -\u003e u32 { if a \u003e minus_b { a - minus_b } else { panic!(\"would overflow!\") } } 이 함수는 리턴값이 성공/실패 여부를 표현하지 않는다. 대신에 실패하면 panic!을 통해 실행을 중단하고 함수 밖으로 탈출하기만 한다.\nTo panic!, or not to panic! 그러면 이 두 가지의 에러 표현 방식, Result와 panic! 중에 무엇을 쓰는 것이 좋을까? 일반적으로 받아들여지는 답은 ‘상황 따라 다르다’이다.\nResult를 써야 할 때 발생 가능한 에러를 기반으로 복구와 재개를 시행할 가능성이 조금이라도 있으면 Result를 사용해야 한다. 예를 들어, 네트워크에서 파일을 다운로드받는 함수를 사용하고 있다 하자. 여러 시나리오가 있겠지만 아무튼 다운로드가 실패했을 때에 무엇을 할 수 있을까? 가장 간단한 방법으로는 n번 재시도해볼 수 있을 것이다. 이런 경우에는 Result와 Error를 사용하는 것이 옳다.\nfn download_file(url: \u0026str) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e { todo!(); } let mut tries = 0; let result = loop { tries += 1; match download_file(\"https://blog.cro.sh/index.xml\") { Err(e) if tries \u003c 3 =\u003e { warn!(\"download failed: {}\", e); continue; } other =\u003e break other, } } panic!을 사용한다면 장황한 catch_unwind를 사용한 코드를 작성해야 하기도 하거니와, exception 처리의 높은 비용을 감수해야만 할 것이다. (혹은, panic = \"abort\"로 인해 애초에 catch_unwind가 불가능할 수도 있다. 또한 일부 에러는 이에 관계없이 무조건 abort하므로 잡을 수 없다.)\npanic!을 써야 할 때 반대로 복구의 가능성이 전혀 없는, 애초에 빠지면 안 되는 상황으로 들어갔을 때에는 panic!이 적절하다. 예를 들어 Vec을 인덱싱할 때 out of bounds 접근을 시도했다면, 처음부터 중대한 실수를 범한 것이기 때문에 Result::Err를 내뱉는다고 딱히 할 일이 없을 것이다. (애초에 이런 상황이 발생하지 않도록 인덱스를 사전에 검사했어야 할 것이다). 그래서 Vec이나 [T]를 인덱싱할 때의 결과값은 T이고 실패 시 panic!을 낸다.\n(만약에 인덱스 체크를 통해 ‘실패 가능한 인덱싱’을 하고 싶다면 .get()을 쓸 수 있다. 이 메서드는 Option를 반환한다.)\n똑똑하게 Result 다루기 unwrap \u0026 expect 둘 모두 Ok를 만나면 값을 꺼내오고 Err를 만나면 panic!하지만, 일반적으로 받아들여지는 쓰임새가 조금씩 다르다.\nunwrap은 assert!와 비슷한 의미로, 항상 Ok여야 해서 안의 값을 꺼내오려 하지만 Err가 발생하는 상황도 버그로 간주하여 고려하겠다는 의도로 사용하곤 한다. expect는 이와 조금 다르게, Err를 만나도 처리할 방법이 도저히 없어 panic!으로 선회하겠다는 의미로 사용하고는 한다. 그래서 panic!에 사용할 추가적인 메시지를 적을 수 있다. try Result를 쓰더라도, 다른 언어의 exception과 비슷하게 오류를 전파하고 싶을 때가 자주 있을 것이다. 예를 들면,\nfn download_files() -\u003e Result\u003cVec\u003cString\u003e\u003e { let file1 = match download_file(\"foo\") { Ok(file) =\u003e file, Err(e) =\u003e return Err(e), }; let file2 = match download_file(\"bar\") { Ok(file) =\u003e file, Err(e) =\u003e return Err(e), }; let file3 = match download_file(\"baz\") { Ok(file) =\u003e file, Err(e) =\u003e return Err(e), }; vec![file1, file2, file3] } 이는 try 연산자라 불리는, ?을 통해 쉽게 달성할 수 있다. 위 예시를 다시 써보면,\nfn download_files() -\u003e Result\u003cVec\u003cString\u003e\u003e { let file1 = download_file(\"foo\")?; let file2 = download_file(\"bar\")?; let file3 = download_file(\"baz\")?; vec![file1, file2, file3] } 훨씬 간결해진 것을 볼 수 있다. Result를 반환하는 함수 위에서 Result를 반환하는 함수를 쓸 때는 대부분 호출한 뒤 ?를 쓰는 패턴을 사용하게 될 것이다.\ntry 연산자는 위 예시보다 조금 더 일반적이라, 반환받은 에러가 반환할 에러 타입으로 변환 가능하기만 하면 사용 가능하다. 즉 다음 코드와 같은 역할을 한다(실제 정의는 조금 다르므로 std::ops::Try를 참고하면 된다).\n// foo()? match foo() { Ok(x) =\u003e x, Err(e) =\u003e return Err(e.into()) } map \u0026 and_then map(FnOnce(T) -\u003e U)은 Result를 Result로 바꿔준다. 즉 에러가 발생했다면 아무 일도 하지 않고, 성공했다면 성공한 결과를 다른 타입으로 변환시킨다.\nmap의 주목할 점은 Result의 에러 여부에 관계없이 성공한 값에 대해 처리를 수행하고, 오류 검사를 나중으로 ‘미룰’ 수 있다는 점이다.\nfn calculate(a: u32, minus_b: u32, bitor_c: u32) -\u003e Result\u003cu32, \u0026'static str\u003e { may_fail(a, minus_b).map(|x| x | bitor_c) } calculate는 may_fail에서 실패할 수도 있지만, 실패를 검사할 책임은 호출자에게 떠넘겨지고 ‘성공했다면’ bitor_c와 binary OR을 수행한 결과를 반환한다.\nmap_err도 자주 쓰이는데, map과 동일한 기능을 Err(E)에 대고 수행해준다. ?의 암시적인 .into() 대신에 수동으로 E를 변환하고 싶을때 주로 같이 쓰인다.\n만약 변환이 아니라 또다른 실패 가능한 함수를 적용하고 싶다면 and_then을 쓰면 된다.\nfn minus_twice(a: u32, minus_b: u32) -\u003e Result\u003cu32, \u0026'static str\u003e { may_fail(a, minus_b).and_then(|x| x.may_fail(a, minus_b)) } 이 때 원본 Result의 E와 적용할 실패 가능한 함수의 리턴형 Result의 E는 같은 타입이어야만 한다. 그래야 별다른 변환 없이 결과를 대입할 수 있기 때문이다.\n이 역시 실패했을 때(즉 Err일 때) 적용 가능한 버전인 or_else가 있으니 참고하기 바란다.\ntranspose Option와 Result간의 상호 변환이다. transpose라는 이름답게 두 타입의 의미를 표로 나열해서 보면 이해가 더 쉬워진다.\nOk Err Some Some(Ok) Some(Err) None None None 여기서 가로와 세로를 ‘뒤집으면’, 아래처럼 바꿀 수 있을 것이다:\nSome None Ok Ok(Some) Ok(None) Err Err Err 반대 방향도 동일하게 처리된다.\nflatten Result",
  "wordCount" : "1207",
  "inLanguage": "en",
  "datePublished": "2023-01-07T23:26:51+09:00",
  "dateModified": "2023-01-07T23:26:51+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://blog.cro.sh/posts/error-handling-story-in-rust-part-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Option::None",
    "logo": {
      "@type": "ImageObject",
      "url": "http://blog.cro.sh/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://blog.cro.sh/" accesskey="h" title="Option::None (Alt + H)">Option::None</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Rust의 에러 처리, Part 1
    </h1>
    <div class="post-meta"><span title='2023-01-07 23:26:51 +0900 KST'>January 7, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Rust에서 어떻게 에러를 처리하고 복구하는지에 대해 실전 위주로 다뤄보고자 한다.</p>
<h1 id="enum-resultt"><code>enum Result&lt;T&gt;</code><a hidden class="anchor" aria-hidden="true" href="#enum-resultt">#</a></h1>
<p>Rust 에러 처리의 중추는 <code>Result</code> 열거형이다. 이 열거형의 정의는 매우 단순하다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Ok(T),
</span></span><span style="display:flex;"><span>    Err(E),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Result is a type that represents either success (Ok) or failure (Err).</p>
</blockquote>
<p>정의에서 볼 수 있듯이, 이는 &lsquo;실패 가능한&rsquo; 값을 표현하는 데 주로 쓰인다. 성공 시 <code>Ok</code>를, 실패 시 <code>Err</code>를 가진다.
열거형이므로, 안에서 성공 또는 실패한 값을 꺼내려면 패턴 매칭을 사용해야 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> Ok::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span>, String<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* if x == 3 { } */</span> <span style="color:#75715e">// 불가능하다. 실패했을 수도 있으니까.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">match</span> x {
</span></span><span style="display:flex;"><span>    Ok(x) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">if</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>    Err(e) <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;oops: {e}&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이를 사용하면 &lsquo;실패 가능한 함수&rsquo;를 표현할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">may_fail</span>(a: <span style="color:#66d9ef">u32</span>, minus_b: <span style="color:#66d9ef">u32</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span>, <span style="color:#f92672">&amp;&#39;</span>static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> a <span style="color:#f92672">&gt;</span> minus_b {
</span></span><span style="display:flex;"><span>        Ok(a <span style="color:#f92672">-</span> minus_b)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Err(<span style="color:#e6db74">&#34;would overflow!&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="panic"><code>panic!</code><a hidden class="anchor" aria-hidden="true" href="#panic">#</a></h1>
<p>깜짝 놀라서 모든 것을 다 내던지고 싶을 때, <code>panic!</code>을 외치면 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>panic!(<span style="color:#e6db74">&#34;망했어요&#34;</span>):
</span></span></code></pre></div><pre tabindex="0"><code class="language-nohiglight" data-lang="nohiglight">thread &#39;main&#39; panicked at &#39;망했어요&#39;, src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre><p><code>panic!</code>은 다른 언어의 exception과 동일하게 구현되어 있다. <code>panic!</code>을 &lsquo;던지면&rsquo;, 바깥의 핸들러가 &lsquo;잡아줄&rsquo; 때 까지
계속해서 호출 스택을 더듬어 올라가게 된다. 그리고 그 기록이 backtrace로 남지만, <code>RUST_BACKTRACE</code> 환경 변수가 <code>1</code>이거나
<code>full</code>인 경우에만 표시되므로 주의가 필요하다. (<code>full</code>의 경우 <code>1</code>에서 쓸 데 없어서 숨겨진 일부 스택도 보여준다)</p>
<p>이러한 기능에는 비용이 들기 때문에, 필요 없는 경우에는 Cargo profile에서 <code>panic = &quot;abort&quot;</code>를 주어 panic이 발생하는 그 즉시
프로그램이 종료되게 할 수도 있다. 관해서는 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#panic">Cargo의 레퍼런스 문서</a>를 참고하기 바란다.</p>
<p>위의 <code>may_fail</code>을 <code>panic!</code>을 써서 다시 만들어 보면 이런 느낌일 것이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">may_fail</span>(a: <span style="color:#66d9ef">u32</span>, minus_b: <span style="color:#66d9ef">u32</span>) -&gt; <span style="color:#66d9ef">u32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> a <span style="color:#f92672">&gt;</span> minus_b {
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">-</span> minus_b
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        panic!(<span style="color:#e6db74">&#34;would overflow!&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이 함수는 리턴값이 성공/실패 여부를 표현하지 않는다. 대신에 실패하면 <code>panic!</code>을 통해 실행을 중단하고 함수 밖으로 탈출하기만 한다.</p>
<h1 id="to-panic-or-not-to-panic">To <code>panic!</code>, or not to <code>panic!</code><a hidden class="anchor" aria-hidden="true" href="#to-panic-or-not-to-panic">#</a></h1>
<p>그러면 이 두 가지의 에러 표현 방식, <code>Result</code>와 <code>panic!</code> 중에 무엇을 쓰는 것이 좋을까? 일반적으로 받아들여지는 답은 &lsquo;상황 따라 다르다&rsquo;이다.</p>
<h2 id="result를-써야-할-때"><code>Result</code>를 써야 할 때<a hidden class="anchor" aria-hidden="true" href="#result를-써야-할-때">#</a></h2>
<p>발생 가능한 에러를 기반으로 복구와 재개를 시행할 가능성이 조금이라도 있으면 <code>Result</code>를 사용해야 한다.
예를 들어, 네트워크에서 파일을 다운로드받는 함수를 사용하고 있다 하자. 여러 시나리오가 있겠지만 아무튼 다운로드가 실패했을 때에 무엇을 할 수 있을까?
가장 간단한 방법으로는 n번 재시도해볼 수 있을 것이다. 이런 경우에는 <code>Result</code>와 <code>Error</code>를 사용하는 것이 옳다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">download_file</span>(url: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>String, Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Error<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    todo!();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>    tries <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> download_file(<span style="color:#e6db74">&#34;https://blog.cro.sh/index.xml&#34;</span>) {
</span></span><span style="display:flex;"><span>        Err(e) <span style="color:#66d9ef">if</span> tries <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            warn<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;download failed: {}&#34;</span>, e);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        other <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">break</span> other,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>panic!</code>을 사용한다면 장황한 <a href="https://doc.rust-lang.org/stable/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>를 사용한 코드를 작성해야 하기도 하거니와,
exception 처리의 높은 비용을 감수해야만 할 것이다. (혹은, <code>panic = &quot;abort&quot;</code>로 인해 애초에 <code>catch_unwind</code>가 불가능할 수도 있다.
또한 일부 에러는 이에 관계없이 무조건 abort하므로 잡을 수 없다.)</p>
<h2 id="panic을-써야-할-때"><code>panic!</code>을 써야 할 때<a hidden class="anchor" aria-hidden="true" href="#panic을-써야-할-때">#</a></h2>
<p>반대로 복구의 가능성이 전혀 없는, 애초에 빠지면 안 되는 상황으로 들어갔을 때에는 <code>panic!</code>이 적절하다.
예를 들어 <code>Vec</code>을 인덱싱할 때 out of bounds 접근을 시도했다면, 처음부터 중대한 실수를 범한 것이기 때문에 <code>Result::Err</code>를 내뱉는다고 딱히 할 일이 없을 것이다.
(애초에 이런 상황이 발생하지 않도록 인덱스를 사전에 검사했어야 할 것이다). 그래서 <code>Vec&lt;T&gt;</code>이나 <code>[T]</code>를 인덱싱할 때의 결과값은 <code>T</code>이고 실패 시 <code>panic!</code>을 낸다.</p>
<p>(만약에 인덱스 체크를 통해 &lsquo;실패 가능한 인덱싱&rsquo;을 하고 싶다면 <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get"><code>.get()</code></a>을 쓸 수 있다.
이 메서드는 <code>Option&lt;T&gt;</code>를 반환한다.)</p>
<h1 id="똑똑하게-result-다루기">똑똑하게 <code>Result</code> 다루기<a hidden class="anchor" aria-hidden="true" href="#똑똑하게-result-다루기">#</a></h1>
<h2 id="unwrap--expect"><code>unwrap</code> &amp; <code>expect</code><a hidden class="anchor" aria-hidden="true" href="#unwrap--expect">#</a></h2>
<p>둘 모두 <code>Ok</code>를 만나면 값을 꺼내오고 <code>Err</code>를 만나면 <code>panic!</code>하지만, 일반적으로 받아들여지는 쓰임새가 조금씩 다르다.</p>
<ul>
<li><code>unwrap</code>은 <code>assert!</code>와 비슷한 의미로, 항상 <code>Ok</code>여야 해서 안의 값을 꺼내오려 하지만 <code>Err</code>가 발생하는 상황도 버그로 간주하여 고려하겠다는 의도로 사용하곤 한다.</li>
<li><code>expect</code>는 이와 조금 다르게, <code>Err</code>를 만나도 처리할 방법이 도저히 없어 <code>panic!</code>으로 선회하겠다는 의미로 사용하고는 한다. 그래서 <code>panic!</code>에 사용할 추가적인 메시지를 적을 수 있다.</li>
</ul>
<h2 id="try"><code>try</code><a hidden class="anchor" aria-hidden="true" href="#try">#</a></h2>
<p><code>Result</code>를 쓰더라도, 다른 언어의 exception과 비슷하게 오류를 전파하고 싶을 때가 자주 있을 것이다. 예를 들면,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">download_files</span>() -&gt; Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> download_file(<span style="color:#e6db74">&#34;foo&#34;</span>) {
</span></span><span style="display:flex;"><span>        Ok(file) <span style="color:#f92672">=&gt;</span> file,
</span></span><span style="display:flex;"><span>        Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e),
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> download_file(<span style="color:#e6db74">&#34;bar&#34;</span>) {
</span></span><span style="display:flex;"><span>        Ok(file) <span style="color:#f92672">=&gt;</span> file,
</span></span><span style="display:flex;"><span>        Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e),
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> download_file(<span style="color:#e6db74">&#34;baz&#34;</span>) {
</span></span><span style="display:flex;"><span>        Ok(file) <span style="color:#f92672">=&gt;</span> file,
</span></span><span style="display:flex;"><span>        Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e),
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    vec![file1, file2, file3]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이는 <code>try</code> 연산자라 불리는, <code>?</code>을 통해 쉽게 달성할 수 있다. 위 예시를 다시 써보면,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">download_files</span>() -&gt; Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file1 <span style="color:#f92672">=</span> download_file(<span style="color:#e6db74">&#34;foo&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file2 <span style="color:#f92672">=</span> download_file(<span style="color:#e6db74">&#34;bar&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> file3 <span style="color:#f92672">=</span> download_file(<span style="color:#e6db74">&#34;baz&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    vec![file1, file2, file3]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>훨씬 간결해진 것을 볼 수 있다. Result를 반환하는 함수 위에서 Result를 반환하는 함수를 쓸 때는 대부분 호출한 뒤 <code>?</code>를 쓰는 패턴을 사용하게 될 것이다.</p>
<p><code>try</code> 연산자는 위 예시보다 조금 더 일반적이라, 반환받은 에러가 반환할 에러 타입으로 변환 가능하기만 하면 사용 가능하다.
즉 다음 코드와 같은 역할을 한다(실제 정의는 조금 다르므로 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Try.html"><code>std::ops::Try</code></a>를 참고하면 된다).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// foo()?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">match</span> foo() {
</span></span><span style="display:flex;"><span>    Ok(x) <span style="color:#f92672">=&gt;</span> x,
</span></span><span style="display:flex;"><span>    Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e.into())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="map--and_then"><code>map</code> &amp; <code>and_then</code><a hidden class="anchor" aria-hidden="true" href="#map--and_then">#</a></h2>
<p><code>map(FnOnce(T) -&gt; U)</code>은 <code>Result&lt;T, E&gt;</code>를 <code>Result&lt;U, E&gt;</code>로 바꿔준다. 즉 에러가 발생했다면 아무 일도 하지 않고, 성공했다면 성공한 결과를 다른 타입으로 변환시킨다.</p>
<p><code>map</code>의 주목할 점은 <code>Result</code>의 에러 여부에 관계없이 성공한 값에 대해 처리를 수행하고, 오류 검사를 나중으로 &lsquo;미룰&rsquo; 수 있다는 점이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">calculate</span>(a: <span style="color:#66d9ef">u32</span>, minus_b: <span style="color:#66d9ef">u32</span>, bitor_c: <span style="color:#66d9ef">u32</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span>, <span style="color:#f92672">&amp;&#39;</span>static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    may_fail(a, minus_b).map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">|</span> bitor_c)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>calculate</code>는 <code>may_fail</code>에서 실패할 수도 있지만, 실패를 검사할 책임은 호출자에게 떠넘겨지고 &lsquo;성공했다면&rsquo; <code>bitor_c</code>와 binary OR을 수행한 결과를 반환한다.</p>
<p><code>map_err</code>도 자주 쓰이는데, <code>map</code>과 동일한 기능을 <code>Err(E)</code>에 대고 수행해준다. <code>?</code>의 암시적인 <code>.into()</code> 대신에 수동으로 <code>E</code>를 변환하고 싶을때 주로 같이 쓰인다.</p>
<p>만약 변환이 아니라 또다른 실패 가능한 함수를 적용하고 싶다면 <code>and_then</code>을 쓰면 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">minus_twice</span>(a: <span style="color:#66d9ef">u32</span>, minus_b: <span style="color:#66d9ef">u32</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span>, <span style="color:#f92672">&amp;&#39;</span>static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    may_fail(a, minus_b).and_then(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x.may_fail(a, minus_b))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이 때 원본 <code>Result</code>의 <code>E</code>와 적용할 실패 가능한 함수의 리턴형 <code>Result</code>의 <code>E</code>는 같은 타입이어야만 한다. 그래야 별다른 변환 없이 결과를 대입할 수 있기 때문이다.</p>
<p>이 역시 실패했을 때(즉 <code>Err</code>일 때) 적용 가능한 버전인 <code>or_else</code>가 있으니 참고하기 바란다.</p>
<h2 id="transpose"><code>transpose</code><a hidden class="anchor" aria-hidden="true" href="#transpose">#</a></h2>
<p><code>Option&lt;Result&gt;</code>와 <code>Result&lt;Option&gt;</code>간의 상호 변환이다. <code>transpose</code>라는 이름답게 두 타입의 의미를 표로 나열해서 보면 이해가 더 쉬워진다.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><code>Ok</code></th>
<th style="text-align:center"><code>Err</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Some</code></td>
<td style="text-align:center"><code>Some(Ok)</code></td>
<td style="text-align:center"><code>Some(Err)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>None</code></td>
<td style="text-align:center"><code>None</code></td>
<td style="text-align:center"><code>None</code></td>
</tr>
</tbody>
</table>
<p>여기서 가로와 세로를 &lsquo;뒤집으면&rsquo;, 아래처럼 바꿀 수 있을 것이다:</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><code>Some</code></th>
<th style="text-align:center"><code>None</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Ok</code></td>
<td style="text-align:center"><code>Ok(Some)</code></td>
<td style="text-align:center"><code>Ok(None)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Err</code></td>
<td style="text-align:center"><code>Err</code></td>
<td style="text-align:center"><code>Err</code></td>
</tr>
</tbody>
</table>
<p>반대 방향도 동일하게 처리된다.</p>
<h2 id="flatten"><code>flatten</code><a hidden class="anchor" aria-hidden="true" href="#flatten">#</a></h2>
<p><code>Result&lt;Result&lt;T, E&gt;, E&gt;</code>를 <code>Result&lt;T, E&gt;</code>로 &lsquo;평평하게 다듬어&rsquo; 준다. 바깥쪽이 성공했으면 안쪽을 쓰고, 실패했으면 실패한 것이다.</p>

<details>
  <summary>사실은, 간단한 구현으로 이를 모사할 수 있다:</summary>
  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>result.and_then(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x) <span style="color:#75715e">// 혹은 std::convert::identity
</span></span></span></code></pre></div>
</details>


<h2 id="collect-result-as-fromiterator"><code>collect</code> (<code>Result as FromIterator</code>)<a hidden class="anchor" aria-hidden="true" href="#collect-result-as-fromiterator">#</a></h2>
<p><code>?</code>를 쓰면 1개의 <code>Result</code>에 대해 검사와 조기 반환을 수행할 수 있다. 근데 임의 개수의 <code>Result</code>에 대해서도 그렇게 할 수 있을까?</p>
<p><code>Result&lt;T, E&gt;</code>는 <code>T: FromIterator&lt;U&gt;</code>면 자신도 <code>FromIterator&lt;Result&lt;U, E&gt;&gt;</code>를 구현한다. 즉 <code>U</code>의 모임을 <code>.collect::&lt;T&gt;()</code>할 수 있다면,
실패 가능한 <code>U</code>, 즉 <code>Result&lt;U, E&gt;</code>의 모임도 <code>.collect::&lt;Result&lt;T, E&gt;&gt;</code>할 수 있다는 것이다. 이는 반복자를 순회하다 첫 번째 에러가 발생할 때 <code>Err(E)</code>가 되어 멈추고,
한 번도 에러가 발생하지 않았다면 <code>Ok(T)</code>가 되는 식으로 구현된다. 이를 사용하면 임의 개수의 <code>Result</code>에 동시에 <code>?</code>를 쓰는 효과를 유도할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> files <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>).map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> download_file(<span style="color:#e6db74">&#34;foo&#34;</span>)).collect::<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;&gt;</span>()<span style="color:#f92672">?</span>;
</span></span></code></pre></div><h2 id="infallible"><code>Infallible</code><a hidden class="anchor" aria-hidden="true" href="#infallible">#</a></h2>
<p>trait 구현 등에서 <code>Result&lt;T, E&gt;</code>의 <code>E</code>에 해당하는 타입을 지정해야 하는데, 절대 실패하지 않을 것을 알고 있다면 타입 레벨에서 이를 표현할 수 있을까?</p>
<p><code>Infallible</code>은 해당하는 값이 단 한개도 없는 &lsquo;빈 자료형&rsquo;으로, 이런 상황에서 에러가 &lsquo;절대 발생하지 않는다&rsquo;는 것을 표현하는 데에 쓸 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Infallible</span> {}
</span></span></code></pre></div><p>즉 다음 함수는 무조건 성공한다: 어떤 경우에도 <code>Err</code>를 반환하지 않는다. <code>Err(E)</code>에 넣을 값 자체가 존재하지 않기 때문이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">always_succeeds</span>() -&gt; Result<span style="color:#f92672">&lt;</span>String, Infallible<span style="color:#f92672">&gt;</span>;
</span></span></code></pre></div><p>아쉽게도 지금은 <code>Result&lt;T, Infallible&gt;</code>에서 <code>String</code>을 즉시 꺼낼 방법이 없다(Nightly에는 존재한다: <code>into_ok</code>를 쓰면 된다). 대신에 <code>match infallible_value {}</code> 를 이용하자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> always_succeeds() {
</span></span><span style="display:flex;"><span>    Ok(x) <span style="color:#f92672">=&gt;</span> x,
</span></span><span style="display:flex;"><span>    Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> e {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="trait-error"><code>trait Error</code><a hidden class="anchor" aria-hidden="true" href="#trait-error">#</a></h1>
<p>지금까지 <code>Result</code>에 대해 장황하게 떠들었지만, 아직 <code>Error</code> 그 자체에 대해서는 이야기하지 않았다. 이에 대해서는 Part 2에서 다뤄보고자 한다.</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>© 2019-2021 Nam Junghyun</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "152863abaa9948f9bb84e53ef4204e47"}'></script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
