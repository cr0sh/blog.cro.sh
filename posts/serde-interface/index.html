<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Serde Interface | Option::None</title>
<meta name="keywords" content="">
<meta name="description" content="Serde는 Rust의 데이터 직렬화/역직렬화를 담당하는 프레임워크로, Rust 생태계의 중추적인 위치를 차지하고 있다. 이번 글에서는 Serde의 인터페이스가 어떻게 정의되었는지 정리해보고자 한다.">
<meta name="author" content="">
<link rel="canonical" href="http://blog.cro.sh/posts/serde-interface/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://blog.cro.sh/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://blog.cro.sh/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://blog.cro.sh/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://blog.cro.sh/apple-touch-icon.png">
<link rel="mask-icon" href="http://blog.cro.sh/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="http://blog.cro.sh/css/allow-horizontal-highlight-scroll.css"><link rel="stylesheet" href="http://blog.cro.sh/css/small-page-heading.css"><link rel="stylesheet" href="http://blog.cro.sh/css/fix-ios-hljs.css"><meta property="og:title" content="Serde Interface" />
<meta property="og:description" content="Serde는 Rust의 데이터 직렬화/역직렬화를 담당하는 프레임워크로, Rust 생태계의 중추적인 위치를 차지하고 있다. 이번 글에서는 Serde의 인터페이스가 어떻게 정의되었는지 정리해보고자 한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.cro.sh/posts/serde-interface/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-21T11:13:05+09:00" />
<meta property="article:modified_time" content="2023-05-21T11:13:05+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Serde Interface"/>
<meta name="twitter:description" content="Serde는 Rust의 데이터 직렬화/역직렬화를 담당하는 프레임워크로, Rust 생태계의 중추적인 위치를 차지하고 있다. 이번 글에서는 Serde의 인터페이스가 어떻게 정의되었는지 정리해보고자 한다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://blog.cro.sh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Serde Interface",
      "item": "http://blog.cro.sh/posts/serde-interface/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Serde Interface",
  "name": "Serde Interface",
  "description": "Serde는 Rust의 데이터 직렬화/역직렬화를 담당하는 프레임워크로, Rust 생태계의 중추적인 위치를 차지하고 있다. 이번 글에서는 Serde의 인터페이스가 어떻게 정의되었는지 정리해보고자 한다.\n",
  "keywords": [
    
  ],
  "articleBody": "Serde는 Rust의 데이터 직렬화/역직렬화를 담당하는 프레임워크로, Rust 생태계의 중추적인 위치를 차지하고 있다. 이번 글에서는 Serde의 인터페이스가 어떻게 정의되었는지 정리해보고자 한다.\nSerde data model Types Serde는 Rust의 타입 시스템을 단순화하여 자체적인 데이터 모델을 정의한다.\n14종의 기본 자료형: bool, {i, u} x {8, 16, 32, 64, 128}, f32, f64, char 문자열과 바이트열. serde의 문자열은 0-byte를 허용한다. 이 둘은 transient/borrowed/owned의 세 가지 형태로 사용될 수 있는데 이는 후술한다. option: None 혹은 Some(T). unit: (). unit_struct: struct Unit 혹은 PhantomData 등. unit_variant: 필드 없는 enum variant. newtype_struct: struct Millimeters(u8) 등. newtype_variant: enum Enum { Variant(u8 }에서 Enum::Variant. seq: 가변 개수의, 서로 타입 다를 수 있는, 여러 값들의 순서 있는 집합. ex) Vec나 HashSet1 tuple: 정적 개수의, 서로 타입 다를 수 있는, 여러 값들의 순서 있는 집합. 역직렬화 시점에 데이터를 읽지 않고도 개수를 미리 알 수 있다는 차이점이 있다. ex) (u8,), (String, u64, Vec), [u64; 10] tuple_struct: 튜플 구조체. ex) struct Rgb(u8, u8, u8) tuple_variant: 튜플 variant. ex) enum Enum { Variant(u8, u8) }에서 Enum::Variant map: 가변 개수의, 서로 타입 다를 수 있는 키-값 쌍들의 집합. ex) BTreeMap. 가변 개수이므로 직렬화 시점에는 전체 데이터를 다 읽기 전까지 개수를 모를 수도 있고, 역직렬화 시점에도 직렬화된 데이터를 끝까지 읽어야 알 수 있다. struct: 정적 개수의, 서로 타입 다를 수 있는 키-값 쌍들의 집합. 키들은 컴파일 시점에 고정된 문자열이며 데이터를 모두 읽지 않고도 알 수 있다 (\u0026'static str'). struct_variant: 열거형의 struct variant. ex) enum Enum { Variant { x: u8 } }의 Enum::Variant Serde data model은 Rust의 것과 유사하기 때문에 비슷한 강력함을 자랑한다. 예를 들어 std::ffi::OsString은 플랫폼마다 표현 방식이 다르므로(Unix는 Vec, Windows는 Vec) 어느 한 쪽으로 가정해서 저장하면 손실이나 정의되지 않은 값이 발생할 수밖에 없는데, 각 플랫폼을 newtype variant로 하는 enum을 정의하면 손쉽게 문제가 해결된다.\nSerialize \u0026 Serializer Rust의 데이터 구조를 직렬화할 때는 Serialize와 Serializer 트레잇이 관여한다. Serialize는 Rust의 데이터 구조(struct, enum, …)에 의해 구현되어서, 자신을 Serde의 데이터 모델로 변환하는 방법을 정의한다. 이 때, 정의된 변환 방법에 따라 Serialize는 Serializer 트레잇의 메서드를 순서대로 호출한다.\nSerializer는 데이터 포맷에 대해 구현되어서, Serialize에 의해 호출될 때마다 Serde 데이터 모델로부터 적절히 직렬화된 데이터를 생성하게 된다.\nRust data --(Serialize)-\u003e Serde data model --(Serilaizer)-\u003e Serialized data 정의를 보면 더 명확해진다. Serialize 트레잇에는 단 하나의 메서드만 존재한다. 직렬화를 위한 일종의 진입 지점이 되는 셈이다.\npub trait Serialize { // Required method fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e where S: Serializer; } Serialize::serialize는 Serde 데이터 모델에 대응되는 메서드를 모두 가지고 있다. serialize_{compound}류의 경우에는 한 번에 모든 데이터를 받을 수 없기 때문에(Rust에는 variadic이 없다), 각 컴파운드 타입마다 별도의 상태 기계를 반환하여 해당 컴파운드 타입의 원소들을 밀어넣을 수 있게 하고 있다.\npub trait Serializer: Sized { type Ok; type Error: Error; type SerializeSeq: SerializeSeq\u003cOk = Self::Ok, Error = Self::Error\u003e; type SerializeTuple: SerializeTuple\u003cOk = Self::Ok, Error = Self::Error\u003e; type SerializeTupleStruct: SerializeTupleStruct\u003cOk = Self::Ok, Error = Self::Error\u003e; type SerializeTupleVariant: SerializeTupleVariant\u003cOk = Self::Ok, Error = Self::Error\u003e; type SerializeMap: SerializeMap\u003cOk = Self::Ok, Error = Self::Error\u003e; type SerializeStruct: SerializeStruct\u003cOk = Self::Ok, Error = Self::Error\u003e; type SerializeStructVariant: SerializeStructVariant\u003cOk = Self::Ok, Error = Self::Error\u003e; // Required methods fn serialize_bool(self, v: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e; fn serialize_i8(self, v: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e; fn serialize_i16(self, v: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e; // ... fn serialize_some\u003cT\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e where T: Serialize + ?Sized; fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e; fn serialize_unit_struct( self, name: \u0026'static str ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e; // ... where T: Serialize + ?Sized; fn serialize_seq( self, len: Option\u003cusize\u003e ) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e; fn serialize_tuple( self, len: usize ) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e; // ... } Deserialize \u0026 Deserializer \u0026 Visitor 역직렬화의 경우 이 세 트레잇이 관여한다. Deserialize는 Rust의 데이터 구조에 대해 구현되어서, Serde의 데이터 모델에서 어떻게 Rust 데이터 구조로 변환될 수 있는지를 정의한다. 이 정의는 Deserializer 트레잇의 메서드를 호출하여 Visitor(를 구현하는 구조체)를 전달하는 식으로 이루어진다.\nDeserializer 트레잇은 데이터 포맷에 대해 구현되어서, 자신이 ‘들고 있는’ 데이터의 일부를 해석할 때마다 전달받은 Visitor의 메서드를 호출한다. Visitor에는 Serde 데이터 모델에 대응되는 visit_* 메서드가 있어서, Serde의 데이터 모델에 해당하는 값이 어떻게 Rust 데이터 구조로 변환될 수 있는지를 정의한다.\n예시를 들어보자. 기본 자료형에 대한 역직렬화 구현은 다음과 같이 한다. (구현하지 않은 visit_* 메서드는 모두 Error::invalid_type을 반환하도록 기본 구현이 주어져 있다.)\nstruct BoolVisitor; impl\u003c'de\u003e Visitor\u003c'de\u003e for BoolVisitor { type Value = bool; fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result { formatter.write_str(\"a boolean\") } fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e where E: Error, { Ok(v) } } impl\u003c'de\u003e Deserialize\u003c'de\u003e for bool { fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e where D: Deserializer\u003c'de\u003e, { deserializer.deserialize_bool(BoolVisitor) } } Vec와 같은 composite type에 대한 역직렬화 구현은 다음과 같다.\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Vec\u003cT\u003e where T: Deserialize\u003c'de\u003e, { fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e where D: Deserializer\u003c'de\u003e, { struct VecVisitor\u003cT\u003e { marker: PhantomData\u003cT\u003e, } impl\u003c'de, T\u003e Visitor\u003c'de\u003e for VecVisitor\u003cT\u003e where T: Deserialize\u003c'de\u003e, { type Value = Vec\u003cT\u003e; fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result { formatter.write_str(\"a sequence\") } fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e where A: SeqAccess\u003c'de\u003e, { let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint())); while let Some(value) = try!(seq.next_element()) { values.push(value); } Ok(values) } } let visitor = VecVisitor { marker: PhantomData, }; deserializer.deserialize_seq(visitor) } } 마지막으로, 다음 구조체에 #[derive(Deserialize)]를 걸고 macro expansion을 보면 아래와 같다. (가독성을 위해 단순화하였음)\nstruct Foo { bar: u32, baz: Option\u003c(i64, f64)\u003e, qux: HashMap\u003cString, u8\u003e, } 코드가 너무 길어서 접었습니다. impl\u003c'de\u003e Deserialize\u003c'de\u003e for Foo { fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e where D: Deserializer\u003c'de\u003e, { enum Field { field0, field1, field2, ignore, } struct FieldVisitor; impl\u003c'de\u003e de::Visitor\u003c'de\u003e for FieldVisitor { type Value = Field; fn expecting(\u0026self, formatter: \u0026mut Formatter) -\u003e fmt::Result { Formatter::write_str(formatter, \"field identifier\") } fn visit_u64\u003cE\u003e(self, value: u64) -\u003e Result\u003cSelf::Value, E\u003e where E: de::Error, { match value { 0u64 =\u003e Ok(Field::field0), 1u64 =\u003e Ok(Field::field1), 2u64 =\u003e Ok(Field::field2), _ =\u003e Ok(Field::ignore), } } fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e where E: de::Error, { match value { \"bar\" =\u003e Ok(Field::field0), \"baz\" =\u003e Ok(Field::field1), \"qux\" =\u003e Ok(Field::field2), _ =\u003e Ok(Field::ignore), } } fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e where E: de::Error, { match value { b\"bar\" =\u003e Ok(Field::field0), b\"baz\" =\u003e Ok(Field::field1), b\"qux\" =\u003e Ok(Field::field2), _ =\u003e Ok(Field::ignore), } } } impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field { fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e where D: Deserializer\u003c'de\u003e, { Deserializer::deserialize_identifier(deserializer, FieldVisitor) } } struct Visitor\u003c'de\u003e { marker: PhantomData\u003cFoo\u003e, lifetime: PhantomData\u003c\u0026'de ()\u003e, } impl\u003c'de\u003e de::Visitor\u003c'de\u003e for Visitor\u003c'de\u003e { type Value = Foo; fn expecting(\u0026self, formatter: \u0026mut Formatter) -\u003e fmt::Result { Formatter::write_str(formatter, \"struct Foo\") } fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e where A: de::SeqAccess\u003c'de\u003e, { let field0 = match de::SeqAccess::next_element::\u003cu32\u003e(\u0026mut seq)? { Some(value) =\u003e value, None =\u003e { return Err(de::Error::invalid_length( 0usize, \u0026\"struct Foo with 3 elements\", )); } }; let field1 = match de::SeqAccess::next_element::\u003cOption\u003c(i64, f64)\u003e\u003e(\u0026mut seq)? { Some(value) =\u003e value, None =\u003e { return Err(de::Error::invalid_length( 1usize, \u0026\"struct Foo with 3 elements\", )); } }; let field2 = match de::SeqAccess::next_element::\u003cHashMap\u003cString, u8\u003e\u003e(\u0026mut seq)? { Some(value) =\u003e value, None =\u003e { return Err(de::Error::invalid_length( 2usize, \u0026\"struct Foo with 3 elements\", )); } }; Ok(Foo { bar: field0, baz: field1, qux: field2, }) } fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e where A: de::MapAccess\u003c'de\u003e, { let mut field0: Option\u003cu32\u003e = None; let mut field1: Option\u003cOption\u003c(i64, f64)\u003e\u003e = None; let mut field2: Option\u003cHashMap\u003cString, u8\u003e\u003e = None; while let Some(key) = match de::MapAccess::next_key::\u003cField\u003e(\u0026mut map) { Ok(val) =\u003e val, Err(err) =\u003e { return Err(err); } } { match key { Field::field0 =\u003e { if Option::is_some(\u0026field0) { return Err(\u003cA::Error as de::Error\u003e::duplicate_field(\"bar\")); } field0 = Some(de::MapAccess::next_value::\u003cu32\u003e(\u0026mut map)?); } Field::field1 =\u003e { if Option::is_some(\u0026field1) { return Err(\u003cA::Error as de::Error\u003e::duplicate_field(\"baz\")); } field1 = Some(de::MapAccess::next_value::\u003cOption\u003c(i64, f64)\u003e\u003e(\u0026mut map)?); } Field::field2 =\u003e { if Option::is_some(\u0026field2) { return Err(\u003cA::Error as de::Error\u003e::duplicate_field(\"qux\")); } field2 = Some(de::MapAccess::next_value::\u003cHashMap\u003cString, u8\u003e\u003e(\u0026mut map)?); } _ =\u003e { let _ = de::MapAccess::next_value::\u003cde::IgnoredAny\u003e(\u0026mut map)?; } } } let field0 = match field0 { Some(field0) =\u003e field0, None =\u003e de::missing_field(\"bar\")?, }; let field1 = match field1 { Some(field1) =\u003e field1, None =\u003e de::missing_field(\"baz\")?, }; let field2 = match field2 { Some(field2) =\u003e field2, None =\u003e de::missing_field(\"qux\")?, }; Ok(Foo { bar: field0, baz: field1, qux: field2, }) } } const FIELDS: \u0026'static [\u0026'static str] = \u0026[\"bar\", \"baz\", \"qux\"]; Deserializer::deserialize_struct( deserializer, \"Foo\", FIELDS, Visitor { marker: PhantomData::\u003cFoo\u003e, lifetime: PhantomData, }, ) } } The 'de lifetime Deserialize\u003c'de\u003e, Deserializer\u003c'de\u003e에 붙어 있는 'de 라이프타임은 역직렬화하기 위해 주어진 데이터의 라이프타임이다. 즉, 해당 데이터로부터 참조를 생성하여 zero-copy 역직렬화를 구현하기 위해서는 해당 라이프타임을 사용해야만 한다.\nstruct Struct\u003c'a\u003e { a: \u0026'a str, } impl\u003c'de\u003e Deserialize\u003c'de\u003e for Struct\u003c'de\u003e {} 구조체가 어떠한 참조도 들고 있지 않은 경우에는 'de 라이프타임이 어떤 것이든 전혀 상관하지 않을 것이다. 이를 HRTB(higher-ranked trait bound)로 표현하면 for\u003c'de\u003e Deserialize\u003c'de\u003e가 될 것이고 Serde에서는 이를 축약하여 DeserializeOwned 라는 trait alias를 두고 있다.\nReferences https://serde.rs/data-model.html https://github.com/serde-rs/serde 작성자 주: HashSet 자체에는 순서가 있을 리 만무하나 serialize/deserialize하는 시점에 순서가 정해지므로(직렬화된 데이터는 항상 순서가 있으니) seq으로 모델링할 수 있다고 생각된다. ↩︎\n",
  "wordCount" : "1401",
  "inLanguage": "en",
  "datePublished": "2023-05-21T11:13:05+09:00",
  "dateModified": "2023-05-21T11:13:05+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://blog.cro.sh/posts/serde-interface/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Option::None",
    "logo": {
      "@type": "ImageObject",
      "url": "http://blog.cro.sh/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://blog.cro.sh/" accesskey="h" title="Option::None (Alt + H)">Option::None</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://blog.cro.sh/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Serde Interface
    </h1>
    <div class="post-meta"><span title='2023-05-21 11:13:05 +0900 KST'>May 21, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Serde는 Rust의 데이터 직렬화/역직렬화를 담당하는 프레임워크로, Rust 생태계의 중추적인 위치를 차지하고 있다. 이번 글에서는 Serde의 인터페이스가 어떻게 정의되었는지 정리해보고자 한다.</p>
<h1 id="serde-data-model">Serde data model<a hidden class="anchor" aria-hidden="true" href="#serde-data-model">#</a></h1>
<h2 id="types">Types<a hidden class="anchor" aria-hidden="true" href="#types">#</a></h2>
<p>Serde는 Rust의 타입 시스템을 단순화하여 자체적인 데이터 모델을 정의한다.</p>
<ul>
<li>14종의 기본 자료형: bool, {i, u} x {8, 16, 32, 64, 128}, f32, f64, char</li>
<li>문자열과 바이트열. serde의 문자열은 0-byte를 허용한다. 이 둘은 transient/borrowed/owned의 세 가지 형태로 사용될 수 있는데 이는 후술한다.</li>
<li>option: <code>None</code> 혹은 <code>Some(T)</code>.</li>
<li>unit: <code>()</code>.</li>
<li>unit_struct: <code>struct Unit</code> 혹은 <code>PhantomData&lt;T&gt;</code> 등.</li>
<li>unit_variant: 필드 없는 enum variant.</li>
<li>newtype_struct: <code>struct Millimeters(u8)</code> 등.</li>
<li>newtype_variant: <code>enum Enum { Variant(u8 }</code>에서 <code>Enum::Variant</code>.</li>
<li>seq: 가변 개수의, 서로 타입 다를 수 있는, 여러 값들의 순서 있는 집합. ex) <code>Vec&lt;T&gt;</code>나 <code>HashSet&lt;T&gt;</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></li>
<li>tuple: 정적 개수의, 서로 타입 다를 수 있는, 여러 값들의 순서 있는 집합. 역직렬화 시점에 데이터를 읽지 않고도 개수를 미리 알 수 있다는 차이점이 있다. ex) <code>(u8,)</code>, <code>(String, u64, Vec&lt;T&gt;)</code>, <code>[u64; 10]</code></li>
<li>tuple_struct: 튜플 구조체. ex) <code>struct Rgb(u8, u8, u8)</code></li>
<li>tuple_variant: 튜플 variant. ex) <code>enum Enum { Variant(u8, u8) }</code>에서 <code>Enum::Variant</code></li>
<li>map: 가변 개수의, 서로 타입 다를 수 있는 키-값 쌍들의 집합. ex) <code>BTreeMap&lt;K, V&gt;</code>. 가변 개수이므로 직렬화 시점에는 전체 데이터를 다 읽기 전까지 개수를 모를 수도 있고, 역직렬화 시점에도 직렬화된 데이터를 끝까지 읽어야 알 수 있다.</li>
<li>struct: 정적 개수의, 서로 타입 다를 수 있는 키-값 쌍들의 집합. 키들은 컴파일 시점에 고정된 문자열이며 데이터를 모두 읽지 않고도 알 수 있다 (<code>&amp;'static str'</code>).</li>
<li>struct_variant: 열거형의 struct variant. ex) <code>enum Enum { Variant { x: u8 } }</code>의 <code>Enum::Variant</code></li>
</ul>
<p>Serde data model은 Rust의 것과 유사하기 때문에 비슷한 강력함을 자랑한다. 예를 들어 <code>std::ffi::OsString</code>은 플랫폼마다 표현 방식이 다르므로(Unix는 <code>Vec&lt;u8&gt;</code>, Windows는 <code>Vec&lt;u16&gt;</code>) 어느 한 쪽으로 가정해서 저장하면 손실이나 정의되지 않은 값이 발생할 수밖에 없는데, 각 플랫폼을 newtype variant로 하는 enum을 정의하면 손쉽게 문제가 해결된다.</p>
<h1 id="serialize--serializer"><code>Serialize</code> &amp; <code>Serializer</code><a hidden class="anchor" aria-hidden="true" href="#serialize--serializer">#</a></h1>
<p>Rust의 데이터 구조를 직렬화할 때는 <code>Serialize</code>와 <code>Serializer</code> 트레잇이 관여한다. <code>Serialize</code>는 <strong>Rust의 데이터 구조</strong>(struct, enum, &hellip;)에 의해 구현되어서, 자신을 Serde의 데이터 모델로 변환하는 방법을 정의한다. 이 때, 정의된 변환 방법에 따라 <code>Serialize</code>는 <code>Serializer</code> 트레잇의 메서드를 순서대로 호출한다.</p>
<p><code>Serializer</code>는 <strong>데이터 포맷</strong>에 대해 구현되어서, <code>Serialize</code>에 의해 호출될 때마다 Serde 데이터 모델로부터 적절히 직렬화된 데이터를 생성하게 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Rust data --(Serialize)-&gt; Serde data model --(Serilaizer)-&gt; Serialized data
</span></span></code></pre></div><p>정의를 보면 더 명확해진다. <code>Serialize</code> 트레잇에는 단 하나의 메서드만 존재한다. 직렬화를 위한 일종의 진입 지점이 되는 셈이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Serialize {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Required method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize</span><span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span>self, serializer: <span style="color:#a6e22e">S</span>) -&gt; Result<span style="color:#f92672">&lt;</span>S::Ok, S::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">where</span> S: <span style="color:#a6e22e">Serializer</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Serialize::serialize</code>는 Serde 데이터 모델에 대응되는 메서드를 모두 가지고 있다. <code>serialize_{compound}</code>류의 경우에는 한 번에 모든 데이터를 받을 수 없기 때문에(Rust에는 variadic이 없다), 각 컴파운드 타입마다 별도의 상태 기계를 반환하여 해당 컴파운드 타입의 원소들을 밀어넣을 수 있게 하고 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Serializer: Sized {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> Ok;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Error</span>: <span style="color:#a6e22e">Error</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SerializeSeq</span>: <span style="color:#a6e22e">SerializeSeq</span><span style="color:#f92672">&lt;</span>Ok <span style="color:#f92672">=</span> Self::Ok, Error <span style="color:#f92672">=</span> Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SerializeTuple</span>: <span style="color:#a6e22e">SerializeTuple</span><span style="color:#f92672">&lt;</span>Ok <span style="color:#f92672">=</span> Self::Ok, Error <span style="color:#f92672">=</span> Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SerializeTupleStruct</span>: <span style="color:#a6e22e">SerializeTupleStruct</span><span style="color:#f92672">&lt;</span>Ok <span style="color:#f92672">=</span> Self::Ok, Error <span style="color:#f92672">=</span> Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SerializeTupleVariant</span>: <span style="color:#a6e22e">SerializeTupleVariant</span><span style="color:#f92672">&lt;</span>Ok <span style="color:#f92672">=</span> Self::Ok, Error <span style="color:#f92672">=</span> Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SerializeMap</span>: <span style="color:#a6e22e">SerializeMap</span><span style="color:#f92672">&lt;</span>Ok <span style="color:#f92672">=</span> Self::Ok, Error <span style="color:#f92672">=</span> Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SerializeStruct</span>: <span style="color:#a6e22e">SerializeStruct</span><span style="color:#f92672">&lt;</span>Ok <span style="color:#f92672">=</span> Self::Ok, Error <span style="color:#f92672">=</span> Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SerializeStructVariant</span>: <span style="color:#a6e22e">SerializeStructVariant</span><span style="color:#f92672">&lt;</span>Ok <span style="color:#f92672">=</span> Self::Ok, Error <span style="color:#f92672">=</span> Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Required methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_bool</span>(self, v: <span style="color:#66d9ef">bool</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Ok, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_i8</span>(self, v: <span style="color:#66d9ef">i8</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Ok, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_i16</span>(self, v: <span style="color:#66d9ef">i16</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Ok, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_some</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(self, value: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Ok, Self::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">where</span> T: <span style="color:#a6e22e">Serialize</span> <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_unit</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Ok, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_unit_struct</span>(
</span></span><span style="display:flex;"><span>        self,
</span></span><span style="display:flex;"><span>        name: <span style="color:#66d9ef">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>
</span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Ok, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">where</span> T: <span style="color:#a6e22e">Serialize</span> <span style="color:#f92672">+</span> <span style="color:#f92672">?</span>Sized;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_seq</span>(
</span></span><span style="display:flex;"><span>        self,
</span></span><span style="display:flex;"><span>        len: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Self::SerializeSeq, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">serialize_tuple</span>(
</span></span><span style="display:flex;"><span>        self,
</span></span><span style="display:flex;"><span>        len: <span style="color:#66d9ef">usize</span>
</span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Self::SerializeTuple, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="deserialize--deserializer--visitor"><code>Deserialize</code> &amp; <code>Deserializer</code> &amp; <code>Visitor</code><a hidden class="anchor" aria-hidden="true" href="#deserialize--deserializer--visitor">#</a></h1>
<p>역직렬화의 경우 이 세 트레잇이 관여한다. Deserialize는 <strong>Rust의 데이터 구조</strong>에 대해 구현되어서, Serde의 데이터 모델에서 어떻게 Rust 데이터 구조로 변환될 수 있는지를 정의한다. 이 정의는 Deserializer 트레잇의 메서드를 호출하여 Visitor(를 구현하는 구조체)를 전달하는 식으로 이루어진다.</p>
<p>Deserializer 트레잇은 <strong>데이터 포맷</strong>에 대해 구현되어서, 자신이 &lsquo;들고 있는&rsquo; 데이터의 일부를 해석할 때마다 전달받은 Visitor의 메서드를 호출한다. Visitor에는 Serde 데이터 모델에 대응되는 <code>visit_*</code> 메서드가 있어서, Serde의 데이터 모델에 해당하는 값이 어떻게 Rust 데이터 구조로 변환될 수 있는지를 정의한다.</p>
<p>예시를 들어보자. 기본 자료형에 대한 역직렬화 구현은 다음과 같이 한다. (구현하지 않은 <code>visit_*</code> 메서드는 모두 <code>Error::invalid_type</code>을 반환하도록 기본 구현이 주어져 있다.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BoolVisitor</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> Visitor<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> BoolVisitor {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expecting</span>(<span style="color:#f92672">&amp;</span>self, formatter: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> fmt::Formatter) -&gt; <span style="color:#a6e22e">fmt</span>::Result {
</span></span><span style="display:flex;"><span>        formatter.write_str(<span style="color:#e6db74">&#34;a boolean&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit_bool</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>(self, v: <span style="color:#66d9ef">bool</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Value, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        E: <span style="color:#a6e22e">Error</span>,
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Ok(v)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> Deserialize<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deserialize</span><span style="color:#f92672">&lt;</span>D<span style="color:#f92672">&gt;</span>(deserializer: <span style="color:#a6e22e">D</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self, D::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        D: <span style="color:#a6e22e">Deserializer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        deserializer.deserialize_bool(BoolVisitor)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Vec&lt;T&gt;</code>와 같은 composite type에 대한 역직렬화 구현은 다음과 같다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span>, T<span style="color:#f92672">&gt;</span> Deserialize<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: <span style="color:#a6e22e">Deserialize</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deserialize</span><span style="color:#f92672">&lt;</span>D<span style="color:#f92672">&gt;</span>(deserializer: <span style="color:#a6e22e">D</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self, D::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        D: <span style="color:#a6e22e">Deserializer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">VecVisitor</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>            marker: <span style="color:#a6e22e">PhantomData</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span>, T<span style="color:#f92672">&gt;</span> Visitor<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> VecVisitor<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>            T: <span style="color:#a6e22e">Deserialize</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span> Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expecting</span>(<span style="color:#f92672">&amp;</span>self, formatter: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> fmt::Formatter) -&gt; <span style="color:#a6e22e">fmt</span>::Result {
</span></span><span style="display:flex;"><span>                formatter.write_str(<span style="color:#e6db74">&#34;a sequence&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit_seq</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> seq: <span style="color:#a6e22e">A</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Value, A::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>                A: <span style="color:#a6e22e">SeqAccess</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> values <span style="color:#f92672">=</span> Vec::with_capacity(size_hint::cautious(seq.size_hint()));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(value) <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span><span style="color:#f92672">!</span>(seq.next_element()) {
</span></span><span style="display:flex;"><span>                    values.push(value);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Ok(values)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> visitor <span style="color:#f92672">=</span> VecVisitor {
</span></span><span style="display:flex;"><span>            marker: <span style="color:#a6e22e">PhantomData</span>,
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        deserializer.deserialize_seq(visitor)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>마지막으로, 다음 구조체에 <code>#[derive(Deserialize)]</code>를 걸고 macro expansion을 보면 아래와 같다. (가독성을 위해 단순화하였음)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    bar: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>    baz: Option<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">i64</span>, <span style="color:#66d9ef">f64</span>)<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    qux: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
<details>
  <summary>코드가 너무 길어서 접었습니다.</summary>
  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> Deserialize<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Foo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deserialize</span><span style="color:#f92672">&lt;</span>D<span style="color:#f92672">&gt;</span>(deserializer: <span style="color:#a6e22e">D</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self, D::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        D: <span style="color:#a6e22e">Deserializer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Field</span> {
</span></span><span style="display:flex;"><span>            field0,
</span></span><span style="display:flex;"><span>            field1,
</span></span><span style="display:flex;"><span>            field2,
</span></span><span style="display:flex;"><span>            ignore,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FieldVisitor</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> de::Visitor<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> FieldVisitor {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span> Field;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expecting</span>(<span style="color:#f92672">&amp;</span>self, formatter: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Formatter) -&gt; <span style="color:#a6e22e">fmt</span>::Result {
</span></span><span style="display:flex;"><span>                Formatter::write_str(formatter, <span style="color:#e6db74">&#34;field identifier&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit_u64</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>(self, value: <span style="color:#66d9ef">u64</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Value, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>                E: <span style="color:#a6e22e">de</span>::Error,
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> value {
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">0</span><span style="color:#66d9ef">u64</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field0),
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">1</span><span style="color:#66d9ef">u64</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field1),
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">2</span><span style="color:#66d9ef">u64</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field2),
</span></span><span style="display:flex;"><span>                    _ <span style="color:#f92672">=&gt;</span> Ok(Field::ignore),
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit_str</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>(self, value: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Value, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>                E: <span style="color:#a6e22e">de</span>::Error,
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> value {
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;bar&#34;</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field0),
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;baz&#34;</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field1),
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;qux&#34;</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field2),
</span></span><span style="display:flex;"><span>                    _ <span style="color:#f92672">=&gt;</span> Ok(Field::ignore),
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit_bytes</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>(self, value: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u8</span>]) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Value, E<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>                E: <span style="color:#a6e22e">de</span>::Error,
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> value {
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;bar&#34;</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field0),
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;baz&#34;</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field1),
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;qux&#34;</span> <span style="color:#f92672">=&gt;</span> Ok(Field::field2),
</span></span><span style="display:flex;"><span>                    _ <span style="color:#f92672">=&gt;</span> Ok(Field::ignore),
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> Deserialize<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Field {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deserialize</span><span style="color:#f92672">&lt;</span>D<span style="color:#f92672">&gt;</span>(deserializer: <span style="color:#a6e22e">D</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self, D::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>                D: <span style="color:#a6e22e">Deserializer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Deserializer::deserialize_identifier(deserializer, FieldVisitor)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Visitor</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>            marker: <span style="color:#a6e22e">PhantomData</span><span style="color:#f92672">&lt;</span>Foo<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>            lifetime: <span style="color:#a6e22e">PhantomData</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#a6e22e">&#39;de</span> ()<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> de::Visitor<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Visitor<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span> Foo;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">expecting</span>(<span style="color:#f92672">&amp;</span>self, formatter: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Formatter) -&gt; <span style="color:#a6e22e">fmt</span>::Result {
</span></span><span style="display:flex;"><span>                Formatter::write_str(formatter, <span style="color:#e6db74">&#34;struct Foo&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit_seq</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> seq: <span style="color:#a6e22e">A</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Value, A::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>                A: <span style="color:#a6e22e">de</span>::SeqAccess<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> field0 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> de::SeqAccess::next_element::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> seq)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>                    Some(value) <span style="color:#f92672">=&gt;</span> value,
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> Err(de::Error::invalid_length(
</span></span><span style="display:flex;"><span>                            <span style="color:#ae81ff">0</span><span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>                            <span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#34;struct Foo with 3 elements&#34;</span>,
</span></span><span style="display:flex;"><span>                        ));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> field1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> de::SeqAccess::next_element::<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">i64</span>, <span style="color:#66d9ef">f64</span>)<span style="color:#f92672">&gt;&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> seq)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>                    Some(value) <span style="color:#f92672">=&gt;</span> value,
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> Err(de::Error::invalid_length(
</span></span><span style="display:flex;"><span>                            <span style="color:#ae81ff">1</span><span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>                            <span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#34;struct Foo with 3 elements&#34;</span>,
</span></span><span style="display:flex;"><span>                        ));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> field2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> de::SeqAccess::next_element::<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> seq)<span style="color:#f92672">?</span> {
</span></span><span style="display:flex;"><span>                    Some(value) <span style="color:#f92672">=&gt;</span> value,
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> Err(de::Error::invalid_length(
</span></span><span style="display:flex;"><span>                            <span style="color:#ae81ff">2</span><span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>                            <span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#34;struct Foo with 3 elements&#34;</span>,
</span></span><span style="display:flex;"><span>                        ));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                Ok(Foo {
</span></span><span style="display:flex;"><span>                    bar: <span style="color:#a6e22e">field0</span>,
</span></span><span style="display:flex;"><span>                    baz: <span style="color:#a6e22e">field1</span>,
</span></span><span style="display:flex;"><span>                    qux: <span style="color:#a6e22e">field2</span>,
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit_map</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>(self, <span style="color:#66d9ef">mut</span> map: <span style="color:#a6e22e">A</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Value, A::Error<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>                A: <span style="color:#a6e22e">de</span>::MapAccess<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> field0: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> field1: Option<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">i64</span>, <span style="color:#66d9ef">f64</span>)<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> field2: Option<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(key) <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> de::MapAccess::next_key::<span style="color:#f92672">&lt;</span>Field<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> map) {
</span></span><span style="display:flex;"><span>                    Ok(val) <span style="color:#f92672">=&gt;</span> val,
</span></span><span style="display:flex;"><span>                    Err(err) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> Err(err);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">match</span> key {
</span></span><span style="display:flex;"><span>                        Field::field0 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span> Option::is_some(<span style="color:#f92672">&amp;</span>field0) {
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> Err(<span style="color:#f92672">&lt;</span>A::Error <span style="color:#66d9ef">as</span> de::Error<span style="color:#f92672">&gt;</span>::duplicate_field(<span style="color:#e6db74">&#34;bar&#34;</span>));
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                            field0 <span style="color:#f92672">=</span> Some(de::MapAccess::next_value::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> map)<span style="color:#f92672">?</span>);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        Field::field1 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span> Option::is_some(<span style="color:#f92672">&amp;</span>field1) {
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> Err(<span style="color:#f92672">&lt;</span>A::Error <span style="color:#66d9ef">as</span> de::Error<span style="color:#f92672">&gt;</span>::duplicate_field(<span style="color:#e6db74">&#34;baz&#34;</span>));
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                            field1 <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                                Some(de::MapAccess::next_value::<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">i64</span>, <span style="color:#66d9ef">f64</span>)<span style="color:#f92672">&gt;&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> map)<span style="color:#f92672">?</span>);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        Field::field2 <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span> Option::is_some(<span style="color:#f92672">&amp;</span>field2) {
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> Err(<span style="color:#f92672">&lt;</span>A::Error <span style="color:#66d9ef">as</span> de::Error<span style="color:#f92672">&gt;</span>::duplicate_field(<span style="color:#e6db74">&#34;qux&#34;</span>));
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                            field2 <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                                Some(de::MapAccess::next_value::<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">u8</span><span style="color:#f92672">&gt;&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> map)<span style="color:#f92672">?</span>);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> de::MapAccess::next_value::<span style="color:#f92672">&lt;</span>de::IgnoredAny<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> map)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> field0 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> field0 {
</span></span><span style="display:flex;"><span>                    Some(field0) <span style="color:#f92672">=&gt;</span> field0,
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> de::missing_field(<span style="color:#e6db74">&#34;bar&#34;</span>)<span style="color:#f92672">?</span>,
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> field1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> field1 {
</span></span><span style="display:flex;"><span>                    Some(field1) <span style="color:#f92672">=&gt;</span> field1,
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> de::missing_field(<span style="color:#e6db74">&#34;baz&#34;</span>)<span style="color:#f92672">?</span>,
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> field2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> field2 {
</span></span><span style="display:flex;"><span>                    Some(field2) <span style="color:#f92672">=&gt;</span> field2,
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> de::missing_field(<span style="color:#e6db74">&#34;qux&#34;</span>)<span style="color:#f92672">?</span>,
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                Ok(Foo {
</span></span><span style="display:flex;"><span>                    bar: <span style="color:#a6e22e">field0</span>,
</span></span><span style="display:flex;"><span>                    baz: <span style="color:#a6e22e">field1</span>,
</span></span><span style="display:flex;"><span>                    qux: <span style="color:#a6e22e">field2</span>,
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">FIELDS</span>: <span style="color:#66d9ef">&amp;</span>&#39;static [<span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>[<span style="color:#e6db74">&#34;bar&#34;</span>, <span style="color:#e6db74">&#34;baz&#34;</span>, <span style="color:#e6db74">&#34;qux&#34;</span>];
</span></span><span style="display:flex;"><span>        Deserializer::deserialize_struct(
</span></span><span style="display:flex;"><span>            deserializer,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Foo&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">FIELDS</span>,
</span></span><span style="display:flex;"><span>            Visitor {
</span></span><span style="display:flex;"><span>                marker: <span style="color:#a6e22e">PhantomData</span>::<span style="color:#f92672">&lt;</span>Foo<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>                lifetime: <span style="color:#a6e22e">PhantomData</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details>


<h3 id="the-de-lifetime">The <code>'de</code> lifetime<a hidden class="anchor" aria-hidden="true" href="#the-de-lifetime">#</a></h3>
<p><code>Deserialize&lt;'de&gt;</code>, <code>Deserializer&lt;'de&gt;</code>에 붙어 있는 <code>'de</code> 라이프타임은 역직렬화하기 위해 주어진 데이터의 라이프타임이다. 즉, 해당 데이터로부터 참조를 생성하여 zero-copy 역직렬화를 구현하기 위해서는 해당 라이프타임을 사용해야만 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Struct</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    a: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> Deserialize<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Struct<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;de</span><span style="color:#f92672">&gt;</span> {}
</span></span></code></pre></div><p>구조체가 어떠한 참조도 들고 있지 않은 경우에는 <code>'de</code> 라이프타임이 어떤 것이든 전혀 상관하지 않을 것이다. 이를 HRTB(higher-ranked trait bound)로 표현하면 <code>for&lt;'de&gt; Deserialize&lt;'de&gt;</code>가 될 것이고 Serde에서는 이를 축약하여 <code>DeserializeOwned</code> 라는 trait alias를 두고 있다.</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<ul>
<li><a href="https://serde.rs/data-model.html">https://serde.rs/data-model.html</a></li>
<li><a href="https://github.com/serde-rs/serde">https://github.com/serde-rs/serde</a></li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>작성자 주: HashSet 자체에는 순서가 있을 리 만무하나 serialize/deserialize하는 시점에 순서가 정해지므로(직렬화된 데이터는 항상 순서가 있으니) seq으로 모델링할 수 있다고 생각된다.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>© 2019-2023 Nam Junghyun</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "152863abaa9948f9bb84e53ef4204e47"}'></script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
