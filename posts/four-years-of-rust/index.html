<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>4년간의 Rust 사용 후기 | Option::None</title>
<meta name="keywords" content="">
<meta name="description" content="2018년 중순부터 4년간 Rust를 사용해보았고, 최근 1년 반 가량은 병역특례를 하면서 프로덕션에서도 사용을 해 보았다.
연말이기도 하니, 그 동안 내가 Rust를 하면서 어떤 인상을 받았는지를 중점으로 하여 되돌아보고자 한다.">
<meta name="author" content="">
<link rel="canonical" href="http://blog.cro.sh/posts/four-years-of-rust/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://blog.cro.sh/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://blog.cro.sh/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://blog.cro.sh/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://blog.cro.sh/apple-touch-icon.png">
<link rel="mask-icon" href="http://blog.cro.sh/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="http://blog.cro.sh/css/allow-horizontal-highlight-scroll.css"><link rel="stylesheet" href="http://blog.cro.sh/css/small-page-heading.css"><meta property="og:title" content="4년간의 Rust 사용 후기" />
<meta property="og:description" content="2018년 중순부터 4년간 Rust를 사용해보았고, 최근 1년 반 가량은 병역특례를 하면서 프로덕션에서도 사용을 해 보았다.
연말이기도 하니, 그 동안 내가 Rust를 하면서 어떤 인상을 받았는지를 중점으로 하여 되돌아보고자 한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.cro.sh/posts/four-years-of-rust/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-11T15:19:56+09:00" />
<meta property="article:modified_time" content="2022-12-11T15:19:56+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="4년간의 Rust 사용 후기"/>
<meta name="twitter:description" content="2018년 중순부터 4년간 Rust를 사용해보았고, 최근 1년 반 가량은 병역특례를 하면서 프로덕션에서도 사용을 해 보았다.
연말이기도 하니, 그 동안 내가 Rust를 하면서 어떤 인상을 받았는지를 중점으로 하여 되돌아보고자 한다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://blog.cro.sh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "4년간의 Rust 사용 후기",
      "item": "http://blog.cro.sh/posts/four-years-of-rust/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "4년간의 Rust 사용 후기",
  "name": "4년간의 Rust 사용 후기",
  "description": "2018년 중순부터 4년간 Rust를 사용해보았고, 최근 1년 반 가량은 병역특례를 하면서 프로덕션에서도 사용을 해 보았다. 연말이기도 하니, 그 동안 내가 Rust를 하면서 어떤 인상을 받았는지를 중점으로 하여 되돌아보고자 한다.\n",
  "keywords": [
    
  ],
  "articleBody": "2018년 중순부터 4년간 Rust를 사용해보았고, 최근 1년 반 가량은 병역특례를 하면서 프로덕션에서도 사용을 해 보았다. 연말이기도 하니, 그 동안 내가 Rust를 하면서 어떤 인상을 받았는지를 중점으로 하여 되돌아보고자 한다.\n주의: 작성자의 사견이 다량 포함되어 있습니다. Rust의 철학 Rust는 폭넓게 쓰이는 다른 언어들에 비해 상당히 이질적인 부분이 많다. 이러한 부분은 기능의 설계 단계에서부터 특정한 철학 혹은 규칙을 적용하여 발생하는 괴리라고 생각이 든다. 이러한 부분에 대해 이해하면 조금 더 Rust를 쉽게 배울 수 있을 것이다.\nZero-cost Abstraction The concept of zero cost abstractions originally came from the functional world. However, the terminology comes from C++. According to Bjarne Stroustrup,\nIn general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better. 1\n보통 zero-cost abstraction을 두 개의 문장으로 번역하여 설명하곤 한다.\n사용하지 않는 기능에는 비용을 지불하지 않는다. 추상화한 코드의 비용이 추상화하지 않은 날것의 구현과 동일하다. 1번의 예를 들어보면, Rust 언어의 주요한 요소 중 하나인 lifetime은 포인터(혹은 레퍼런스)의 유효성을 런타임이 아닌 컴파일 타임에 검증하기 위해 존재한다.\nJavaScript를 예로 들어보자. 객체를 변수에 담는다는 것은, 사실은 특정 객체를 바라보는 레퍼런스를 변수에 담는다는 것이고, 그 객체에 직접 접근할 수는 없다. 그리고 대입(=) 연산을 통해 변수를 ‘복제’하여도, 새로운 객체가 복제되어 생성되는 것이 아니라 같은 객체를 바라보는 레퍼런스가 하나 더 생기는 것이다. 그러면 우리는 레퍼런스가 항상 ‘살아 있는’ 객체를 바라본다는 것을 어떻게 확신할 수 있을까? 답은 역설적이게도 ‘자신을 바라보는 레퍼런스가 존재하는 동안에는 객체가 항살 살아 있는다’는 것이다.\n다시 말해, JavaScript는 런타임에 자신을 바라보는 레퍼런스의 수, 유식한 말로 refcount를 추적하는 비용은 프로그래머의 의도와 관계없이 고정으로 지출되는 것이다. (요즘 자바스크립트 엔진은 상당한 최적화가 되어 있어서 자명한 경우에는 없앨 수도 있겠다.)\nRust의 경우에는 더 엄격한 규칙을 적용해서 컴파일 타임에 각각의 값들이 언제 사라져도 안전한지를 추적하고, 런타임에는 그러한 비용이 들지 않도록 설계했는데, 이 ‘언제’ 시점을 lifetime이 결정한다고 보면 된다.\n2번의 예도 들어보자. Java에서 오버라이드된 메서드를 호출할 때는 메서드의 실제 구현을 찾은 뒤에 해당 구현을 사용해야 하기에, dynamic dispatch라고 불리는 기능이 필요하다. Dynamic이라는 말이 들어간 기능답게, 이는 공짜가 아니다. JVM에서 최적화를 할 수는 있겠지만 비용을 0으로 만들 수는 없다.\nRust의 경우에는 (trait object를 제외하면) 모두 static dispatch를 수행한다. 다르게 말하면, 컴파일 시점에 모든 함수 호출이 어느 구현을 사용해야 하는지 알게 되는 것이다(대신 이 또한 Java에 비해 이질적이거나 경직된 설계를 유도하는 원인이 된다).\nZero-cost abstraction이 주는 제약도 많지만, 나는 Rust가 C++와 경쟁하며 더 나아가 수많은 플랫폼에서 실행 가능하도록 하는 데 기여했다고 생각한다. 이는 ‘Rust의 장점’ 문단에서 다시 언급하겠다.\n암묵적보다는 명시적 표현을 지향 C에서의 integer promotion을 기억하는가?\nIf an int can represent all values of the original type (as restricted by the width, for a bit-field), the value is converted to an int; otherwise, it is converted to an unsigned int. These are called the integer promotions. All other types are unchanged by the integer promotions. 2\n대충 요약하면 C에서의 정수 연산은 손실이 일어나지 않는 한 암시적으로 각 값을 int 혹은 unsigned int로 변환 후 계산한다.\nC가 아니더라도, Javascript의 1 + 'a'라던가 하는, 암시적 형변환이 가져올 수 있는 footgun이나 숨겨진 비용 문제를 제거하기 위해서 Rust는 가능한 한 명시적으로 코드를 표현하는 것을 좋아하는 것으로 보인다. 예를 들어 dynamic dispatch를 가능케 하는 trait object는 원래 trait 이름 그 자체만 쓰면 되었지만 Rust 2018부터는 dyn이라는 키워드를 앞에 붙여야 하도록 바뀌었다. 앞서 말한 타입캐스팅도 모두 as 키워드나 try_from(정보 손실이 가능한 경우에는 대부분 후자가 권장된다) 메서드를 명시적으로 사용해야만 발생한다.\nRust의 장점 내가 4년 동안, 질리지도 않고 Rust를 사용할 수 있었던 이유를 소개해보고자 한다.\n매우 강력한 타입 시스템과 이에 따라붙는 표현력 Rust의 타입 시스템은 해결하고자 하는 문제를 모델링할 때 거슬릴 일이 없을 정도로 매우 강력하고, 타입 추론과 타입 레벨 연산 기능도 아주 훌륭해서 zero-cost abstraction을 달성하는 데에 많은 도움을 준다. 그 중에서 몇 개를 꼽아보자면…\nGenerics Rust의 일반화 프로그래밍은 아주 강력해서, 다음의 기능들을 가지고 있다\nTrait: 타입의 ‘특성’ 을 서술할 수 있다. 이 타입은 전순서를 가진다거나, 문자열로 변환 가능하다던가… (interface처럼 다중 구현이 가능하지만 abstract class처럼 default implementation이 가능한, 중간의 무언가로 봐도 무방하다.)\npub trait Ord: Eq + PartialOrd\u003cSelf\u003e { fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering; fn max(self, other: Self) -\u003e Self { ... } fn min(self, other: Self) -\u003e Self { ... } fn clamp(self, min: Self, max: Self) -\u003e Self where Self: PartialOrd\u003cSelf\u003e, { ... } } 값이 전순서를 가짐을 표현하는 Ord는, 순서 정의인 cmp만 구현하면 max, min, clamp 메서드의 default implementation이 따라온다.\nType bound: 타입 파라미터에 trait/lifetime 조건을 명시할 수 있다.\nfn find_max\u003cT: Ord\u003e(xs: \u0026[T]) -\u003e \u0026T { // T가 Ord를 구현해야 사용 가능하다 match xs.len() { 0 =\u003e panic!(\"xs is empty\"), 1 =\u003e \u0026xs[0], _ =\u003e { let mut max = \u0026xs[0]; for x in xs { if x \u003e max { // 여기서 T: Ord가 필요해진다 max = x; } } max } } } Generic trait: Trait에도 타입 파라미터를 붙일 수 있다. 가장 간단한 예시로 From를 보자.\npub trait From\u003cT\u003e { fn from(T) -\u003e Self; } 어떤 타입이 From 를 구현하면, T로부터 자신(Self)으로 자명하게 변환 가능하다는 뜻이다.\nAssociated type: Trait에 ‘연관된’ 타입을 정의하여 구현하는 타입이 지정헤주도록 강제할 수 있다. From의 ‘실패 가능한’ 버전인 TryFrom를 보자.\npub trait TryFrom\u003cT\u003e { type Error; fn try_from(value: T) -\u003e Result\u003cSelf, Self::Error\u003e; } 어떤 타입이 TryFrom를 구현하려면, ‘실패 가능한’ T로부터 오는 변환도 정의하고, 변환이 실패했을 때 반환할 리턴 타입도 지정해야 한다.\nGeneric implementation: 함수와 trait만 일반화 가능한 것이 아니라, impl 블록도 일반화가 가능하다. 즉 특정 조건을 만족하는 타입 모두에 대해서 다른 Trait에 대한 구현을 추가할 수 있다.\nimpl\u003cT, U\u003e Into\u003cU\u003e for T where U: From\u003cT\u003e, { fn into(self) -\u003e U { U::from(self) } } Into 는 From 의 ‘역순’ trait으로, T -\u003e U 방향을 뒤집어서 U -\u003e T 방향으로 (something.into()와 같이) 사용 가능하도록 해 주는 trait이다(From이 존재하는데 Into가 왜 필요하냐고 의문을 가질 수 있지만, 매우 사소한(?) 이유이므로 일단 있다는 사실만 알고 가자).\n이 Into를 U: From를 만족하는 U에 해당하는 각각의 타입에 대고 구현하는 것은 불가능하므로, 일반화된 impl을 사용하여 모든 타입에 대해 한 번에 구현하는 것이다.\nGeneric associated type: associated type도 일반화시킬 수 있다. 다시 말해 associated type도 타입 파라미터를 가질 수 있다는 것인데, 조금 복잡한 예시를 하나 들어보면:\ntrait PointerFamily { type Pointer\u003cT\u003e: Deref\u003cTarget = T\u003e; fn new\u003cT\u003e(value: T) -\u003e Self::Pointer\u003cT\u003e; } struct ArcFamily; impl PointerFamily for ArcFamily { type Pointer\u003cT\u003e = Arc\u003cT\u003e; fn new\u003cT\u003e(value: T) -\u003e Self::Pointer\u003cT\u003e { Arc::new(value) } } struct RcFamily; impl PointerFamily for RcFamily { type Pointer\u003cT\u003e = Rc\u003cT\u003e; fn new\u003cT\u003e(value: T) -\u003e Self::Pointer\u003cT\u003e { Rc::new(value) } } struct Foo\u003cP: PointerFamily\u003e { bar: P::Pointer\u003cString\u003e, } 3\n여러 종류의 (스마트) 포인터를 PointerFamily라는 하나의 trait으로 묶어서 표현할 수 있게 된다. 포인터는 Rc, Arc와 같이 그 자체로 일반화되어있으므로 한 차원 위에서 다시 한번 일반화하는 기능이 필요한데, 이를 GAT를 사용하여 표현하는 것이다.\n이렇게 Rust의 강력한 일반화 프로그래밍 기능을 아래의 ADT와 조합하면, 사실상 거의 모든 문제상황을 타입으로 모델링할 수 있게 된다.\nADT: enum과 패턴 매칭 Algebraic Data Type의 줄임말로, 타입을 이를 만족하는 값들의 집합으로 보았을 때 집합 간의 연산 결과로 나오는 타입을 말한다. 일반적으로 ‘합연산’과 ‘곱연산’을 따지는데, 각각 Rust의 enum과 struct에 대응된다. 다시 말해, enum은 ‘or’, struct는 ‘and’를 뜻하기 때문에 표현하고 싶은 상황을 타입으로 나타내기에 매우 적합하다.\n예를 들어, 3층짜리 찬장에 있는 세 가지 색깔의 컵이 어떻게 배치되어 있는지 알고 싶다고 하자. 찬장의 각 ‘층’은 동시에 존재하므로, ‘and’ 연산인 struct를 이용하도록 한다.\nstruct Cupboard { first: Vec\u003cCup\u003e, second: Vec\u003cCup\u003e, third: Vec\u003cCup\u003e, } 컵의 경우에는 세 가지 색깔이 있고 동시에 두 가지 색을 가질 수는 없으므로 ‘or’ 연산인 ’enum’을 이용하면 되는 것이다.\nenum Cup { Red, Blue, Green, } 더 나아가서, Rust의 enum에는 각 variant마다 값을 넣을 수 있다. 만약 찬장에 넣을 수 있는 것이 접시도 있다면?\nenum Object { Cup(Cup), Dish(Dish), } 이번에는, 접시를 쌓아서 보관할 수도 있다면?\nenum Object { Cup(Cup), Dish(Dish), StackedDish(Vec\u003cDish\u003e), } 이렇게 만들어진 enum이나 struct에서 값을 뽑아오려면, 패턴 매칭을 사용할 수 있다(struct의 경우 다른 언어와 동일하게 .으로 접근하는 것도 가능하다).\nmatch object { Cup(cup) =\u003e { /* ... */ } Dish(dish) =\u003e { /* ... */ } StackedDish(stacked_dish) =\u003e { /* ... */ } } 각각의 match 곁가지들에서 각 variant가 담고 있는 값을 변수로 할당하여 사용 가능한 것을 알 수 있다.\n패턴 매칭은 단순히 ‘한 겹’ 벗기는 것을 넘어 중첩된 패턴에도 매칭할 수 있다.\nmatch (object1, object2) { // 두 값에 대해 동시에 매칭하면서, 안쪽의 값에 대해서도 한번 더 매칭 (Cup(Cup::Red), Cup(Cup::Blue)) =\u003e { /* ... */ } // 두 값에 대해 동시에 매칭하면서, 안쪽의 값을 써서 추가적인 조건 제시 (Cup(a), Cup(b)) if a == b =\u003e { /* ... */ } // Cup: Eq 라 가정하자. // _ 는 항상 매칭에 성공하는 값이다. (Dish(dish), _) =\u003e { /* ... */ } (StackedDish(stacked_dish), _) =\u003e { /* ... */ } // 위의 패턴들 중 아무것도 만족하지 않으면... _ =\u003e { /* ... */ } } 조금 더 현실적인 enum의 예시로는, 에러 핸들링의 중추가 되는 Result 타입이 있다.\nenum Result\u003cT, E\u003e { Ok(T), Err(E) } (여기서 알 수 있겠지만 enum이나 struct도 일반화할 수 있다.)\n높은 런타임 성능 Rust의 zero-cost abstraction 덕분에, Rust 프로그램은 얼마든지 필요한 만큼만 사용하는 ‘가벼운’ 코드를 작성할 수 있다(주의: 약간의 예외 있음). 이는 높은 범용성과도 맞물리는데, 좀 더 아래에서 서술하겠다.\nZero-cost Asynchronous Programming Rust에서 제일 강력한 기능 중 하나를 꼽으라면, 나는 망설임 없이 async/await을 선택할 것이다. 다른 언어에서 구현하는 비동기 프로그래밍과는 약간의 차이가 있지만(체계 자체가 조금 더 명시적이다), 손으로 state machine을 짜서 구현한 것과 대등한 성능을 보이며4 GC가 필요없는 언어 중에서는 Rust가 독보적으로 편의성과 안전성 면에서 우위를 점하고 있다.\n특히 이는 대규모 네트워크 서비스를 제공하는 기업에서 저지연, 고부하 조건을 만족해야 할 때 크게 작용하는데, Discord는 GC로 인한 지연시간 편차로 인해 Rust로 특정 마이크로서비스를 재작성하여 큰 성능 향상을 얻었고, CloudFlare는 내/외부망을 연결하는 프록시를 NGINX에서 자체 Rust 구현으로 교체하여 CPU 자원을 더 효율적으로 사용하기도 했다. 덤으로 얻는 memory safety 덕에 CloudFlare는 수백조 단위의 요청을 처리히면서 단 한번의 프록시 버그로 인한 크래시도 경험하지 않았다고 한다. 오히려 하드웨어 문제와 알려지지 않은 리눅스 커널의 버그를 찾기까지 했다고…\n개발 도구의 성숙함 개인적으로 Visual Studio보다는 한 수 아래라고 생각하지만, 다른 ‘신생’ 언어들과 비교하면 독보적인 1순위를 달리고 있지 않나 생각한다. 빌드 시스템과 의존성 관리 역할을 해 주는 cargo는 다른 언어에서 벤치마킹할 정도로5 Rust의 장점 중 하나로 꼽히고, Rust 툴체들의 버전 관리 및 설치를 도와주는 rustup도 매우 편리하다. LSP 구현체인 rust-analyzer 덕분에 LSP 클라이언트가 내장된 많은 에디터에서 IDE와 비슷한 경험을 가질 수도 있다.\nMemory Safety 앞서 말한 zero-cost abstraction을 통해 궁극적으로 Rust는 ‘memory safety’를 달성한다. Rust에서 unsafe 코드를 사용하지 않는 한, 컴파일되는 모든 코드는 메모리 버그를 일으키지 않음이 보장된다. 아주 가끔씩 safe 코드만으로 undefined behavior를 만들어낼 수 있는 구멍이 발생하지만(soundness hole), 그러한 동작들은 명백히 버그로 규정되어 최우선적으로 수정된다.\n범용성 위에서 계속 언급했듯이, Rust 코드는 수많은 플랫폼에서 구동되고 있다.\n데스크탑 및 스마트폰 OS의 컴포넌트와 같은 시스템 라이브러리 Windows, Linux, MacOS, Android, iOS 고성능 웹 백엔드 Linux Kernel 드라이버 (\u003e= 6.1) eBPF 및 WebAssembly 블록체인(블록체인 노드, 스마트 컨트랙트 구현 등에 모두 쓰인다). 임베디드 프로그래밍(이 쪽은 비교적 생태계가 약하다) 이것이 가능한 이유는 Rust가 근본적으로 zero-cost abstraction을 지향하기 때문에, 다른 플랫폼에 올려놓아도 추가적인 비용이 거의 발생하지 않기 때문이다. 예를 들어 Javascript를 eBPF 위에 올리려 하면, 가비지 컬렉션이나 약한 동적 타입 시스템의 비용이 필연적으로 따라오게 될 것이다. (AssemblyScript와 같이 파편화된 생태계가 발생할 수도 있다).\nRust의 단점 여기까지만 보면 Rust는 ‘완전한’ 언어 같지만, 그렇지 않다. Rust를 사용해보면서 그러한 결점들을 크게 체감할 수 있었다.\n높은 진입 장벽 Rust는 어려운 문제를 쉽게 추상화하지 않는다(쉽게 추상화하면 반드시 비용이 발생하는 지점이 있기 때문이다)6.\n예를 들어, Rust에서 문자열 처리를 하고 싶으면 다음의 타입들에 대해 이해할 필요가 있다:\nString (힙에 할당된 UTF-8 문자열)\n\u0026str (문자열 ‘슬라이스’. UTF-8로 표현된 바이트열을 바라보는 레퍼런스)\n\u0026String은 거의 사용되지 않고, 대부분의 경우에 \u0026str을 사용하는 것이 권장된다. \u0026[u8] (바이트열. 그 자체로 문자열은 아니지만 파싱 전에 만날 확률이 높다)\nCow (‘Copy-on-Write’ 문자열. 복사를 최소화하고 싶을 때 만날 수 있다)\nimpl AsRef (그 자체로 타입은 아니지만, \u0026str과 String을 동시에 처리하고 싶을 때 사용할 수 있다)\nOsString, CString, Path와 같이 특수한 목적을 지닌 타입들을 거론하지 않았는데도 벌써 공부할 것이 산더미가 되었다. 다른 언어들은 모르는 부분을 배제하고 쉬운 길로 (비용을 지불하고)나아갈 수 있지만, Rust의 경우에는 그것을 허용하지 않아 학습자를 좌절시키는 경우가 허다하다.\n물론 Rust도 ‘쉬운 길’을 택하는 방법이 존재하지만, 대부분의 실전 코드들은 그렇지 않기 때문에 어떻게 비용을 지불하는지조차도 알기 어려운 경우가 많다.\n설계의 제약 일반화 프로그래밍과 ADT를 찬양했다가 제약이 있다고 하면 모순되지 않냐고 할 수도 있지만, Rust의 타입 시스템이 ‘인전하며 비용 없이’ 표현하는 것이 불가능한 구조도 있다. 자기참조/순환참조 구조가 그것인데, lifetime의 존재로 인해 모든 Rust의 값들 간의 참조 관계는 DAG(방향 있고 순환 없는 그래프)로 표현될 수밖에 없다. 순환 참조가 발생하는 순간 lifetime을 정의할 수 없기 때문에 컴파일에 실패한다.\n물론 Arc::new_cyclic 과 같이 순환참조를 가능케 하는 도구들도 있으나, weak pointer를 사용한다던가 하는 식으로 추가적인 비용(메모리 할당 포함)을 지불하거나, Pin::new_unchecked를 써서 unsafe하게 작성해야 한다. (후자는 ouroboros라는 crate가 자기참조를 편하게 구성할 수 있도록 해 준다고 하는데, 직접 써보지는 않아서 언급하지는 않겠다.)\n대부분의 경우에는 이러한 구조가 필요하지 않도록 설계하는 것이 최선인데, 다른 언어를 사용하다 진입한 초심자 입장에서는 어려울 수밖에 없다. C/C++/Java 등으로 작성된 프로그램을 한줄 한줄(line-by-line) 번역해 이식하는 것이 불가능해지기 때문이다. 그러한 언어들에서는 자기참조나 순환참조 구조가 나타나는 패턴이 종종 보이곤 한다. (링크드 리스트라던가, 양방향 그래프라던가)\n자기참조가 아니더라도, Rust의 borrow checker와 궁합이 맞지 않는 패턴들이 여럿 존재하는데, 예를 들어 이벤트 리스너와 callback이 주가 되는 옵저버 모델의 경우 callback이 사용하는 값들의 생명주기를 컴파일 타임에 추적하는 것이 힘들기 때문에 추가적인 할당이나 레퍼런스 카운팅이 필요해지게 될 것이다. 물론 이러한 부분에 대해서만 주의 깊게 unsafe 코드를 작성하거나 비용을 지불하여 모듈화하는 식으로 격리할 수는 있지만(Rust의 표준 라이브러리에서도 링크드 리스트와 이진 트리를 제공한다.) Rust가 의도하는 이상이 항상 현실에 100% 적용될 수는 없다는 사실을 인지해야 한다.\n그리고 이러한 ‘격리’ 작업에 unsafe를 쓰는 경우 ‘올바르게’ 마무리하는 것이 아주 어려운 것으로 평가된다. Rust의 memory safety 등이 제공하는 보장의 특성상, 지켜야 하는 규칙이 엄격하고 이를 위반할 시에 컴파일러의 공격적인 최적화로 인한 오작동이 더 큰 문제를 일으킬 수 있기 때문이다.\n비교적 낮은 생산성(개발 속도) 숙련된 Rust 프로그래머도 lifetime, borrow checker, type checker와 씨름하는 일이 자주 발생한다. 빠르게 구현해서 내보내는 프로세스가 정립된 B2C 서비스들을 운영하는 기업의 경우에는 Rust를 도입했을 때 개발 속도가 비교적 떨어질 수도 있음을 명심해야 한다.\n사견으로, 이는 Go가 웹 백엔드 분야에서 크게 유행한 이유와 거의 정반대되는데, Go는 복잡한 문제도 비용을 내고 쉽게 추상화하며, 타입 시스템에 별다른 기능이 없고(1.18에야 일반화 프로그래밍이 정식으로 추가되었다), 다른 기능도 많지 않아 진입장벽이 매우 낮기 때문에 높은 생산성을 기대할 수 있다. 매크로 이 기능은 Rust에서 무제한에 가까운 메타프로그래밍을 할 수 있게 해주는 강력한 도구이지만, 개인적으로는 썩 좋아하지 않기 때문에 여기서 서술하고자 한다.\n첫 번째로, 매크로는 문법 토큰 트리를 받아서 특정 작업을 수행하여 새로운 문법 트리를 반환하는 규칙이라고 말할 수 있는데, 설명에서도 유추할 수 있듯이 기존의 Rust 지식과는 판이한, Rust의 문법 구조에 관한 지식을 습득해야만 사용 가능하다. 다시 말해, 매크로는 사실상 Rust 문법만 차용한 또다른 Rust 안의 미니 언어로서 기능한다는 점에서 개발 경험의 괴리를 발생시킨다. (이 단점은 두 가지 종류의 매크로 정의 방식인 procedural macro와 declarative macro에 모두 해당된다.)\n두 번째로, proc-macro는 매크로를 적용하려는 코드 이전에 컴파일되어야 하기 때문에 전체적인 컴파일 시간을 증가시킨다. 특히 이는 소스코드만을 압축해서 올리는 Rust의 crate 시스템과 맞물려 문제를 가중시키는데, proc-macro를 미리 컴파일한 결과를 게시할 수 없기 때문이다. (관련하여 watt라는 실험적인 WebAssembly 기반 proc-macro 런타임이 있지만 메인스트림에 들어오기는 아직 곤란하다.)\n세 번째로, IDE와 proc-macro 간의 조화가 좋은 편은 아니라 proc-macro를 지나치게 많이 사용하는 경우 개발 경험이 오히려 감소하게 되는 경우가 발생할 수 있다.\n‘전통적인’ 매크로 정의 방법인 ‘decl-macro’, 다른 말로 macros by example 방식은 상술한 두 번째와 세 번째 문제에 대해 비교적 자유롭지만, proc-macro보다도 더 이질적인 문법과 정의 방식을 가지고 있고(간단히 설명하면, Rust 코드의 문법 구조에 대해 패턴 매칭을 시도한다), 표현 가능한 범위에도 제약이 있어서 기능의 복잡도가 특정 지점을 넘으면 사용할 수 없게 된다. (그 예시로, 동일한 기능을 수행하는 pin-project와 pin-project-lite를 보면 전자는 proc-macro, 후자는 macros by example 방식인데 후자는 전자의 일부 기능을 제거했음에도 불구하고 훨씬 더 이해하기 어렵다).\n마이너리티 Rust 구인/구직 시장은 Go와 비교해서도 매우 좁다. 특히 한국은 격차가 훨씬 심하다.\n결론: 10년 뒤에도 Rust로 밥벌이가 가능할까? 단점을 줄줄이 나열했지만 답은 ‘yes’라고 생각한다. 내가 생각하는 현재(그리고 근미래)의 Rust 사용처는 다음과 같다.\n대규모 서비스의 백엔드 현재로서는, 감히 말하건데 다음의 상황에서 Rust를 이길 대안은 없다.\n대규모 서비스를 운영하여 높은 워크로드를 가지고 I/O가 매우 잦으며 불특정 다수에게 서비스(B2C)하여 강건성을 특히 신경써야 하는 (이들 중 두 개만 해당되어도 아주 매력적인 선택이 된다)\n흔히 말하는 ‘빅테크’ 백엔드 분야에서는 Rust의 zero-cost abstraction, async/await, memory safety는 독보적인 매력을 가진다. 한 가지 문제점은 이러한 매력이 비교적 작은 조직에서는 어필되기 어렵다는 점이다.\n크로스플랫폼 비즈니스 로직 모듈 Rust의 표현력과 범용성은 여러 플랫폼에서 공유되어야 하는 비즈니스 로직을 작성할 때 큰 이점이 된다. rustc의 타깃 목록을 보면, 주로 사용되는 PC/모바일 플랫폼들은 모두 Tier 1/2에 들어가 있는 것을 볼 수 있다. 즉 Rust 코드를 각 플랫폼에 대해 네이티브로 빌드하여 사용하여도 무방하다. 또한 rust-bindgen, cbindgen 등을 사용하면 C FFI를 통해 플랫폼 고유 코드와 소통하는 데에도 어려움이 없다.\n이 부분은 인프콘 2022에서 크로스플랫폼 Rust를 발표한 자료를 참고하면 좋을 것으로 보인다.\nFFI로 호출 가능한 고성능 연산 모듈 최근에 알게 되어 아직 검토가 부족하지만 불확실함을 무릅쓰고 여기에 주장을 남겨 보면, Rust의 비교적 경직된 설계를 최소화할 수 있는 방법으로 동적 스크립팅 언어와의 바인딩으로 사용하는 방법이 유효할 것으로 생각된다. 예를 들어, Python에 쉽게 Rust 코드를 붙일 수 있는 PyO3나, Ruby 익스텐션을 쉽게 만들 수 있는 Magnus 등을 사용하여 스크립팅을 위주로 작성하되 병목 지점에서 Rust로 작성한 모듈을 사용하여 고성능을 꾀하는 방식이다. 개인적으로는 LuaJIT과의 연동에 관심이 있는데, mlua라는 crate가 있어 주의깊게 지켜보고 있다.\n마무리 Rust를 선도적으로 도입한 사례들에서 알 수 있듯이, 소수의 빅테크 회사들을 시작으로 한 Rust의 물결은 이제 부정하기 어렵게 되었다. 상술하였듯이 Rust가 모든 상황에서 만능으로 사용 가능한 은탄환이 될 수는 없는 걸 알면서도, Rust를 좋아하는 개발자 입장에서는 Rust가 지금보다 훨씬 폭넓은 범위에서 사용되었으면 하는 바램이 있다. 앞으로도 Rust를 써서 좋아하는 일을 할 수 있기를 기대하며 부족한 회고록을 마치도록 하겠다.\nhttps://stackoverflow.com/a/73518476 ↩︎\nhttps://stackoverflow.com/a/44456310 ↩︎\nhttps://rust-lang.github.io/rfcs/1598-generic_associated_types.html#associated-type-constructors-of-type-arguments ↩︎\nhttp://aturon.github.io/tech/2016/08/11/futures ↩︎\nhttps://github.com/python-poetry/poetry/tree/c5c7624ef64f34d9f50c3b7e8118f7f652fddbbd#why ↩︎\nhttps://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride#parting-words ↩︎\n",
  "wordCount" : "2790",
  "inLanguage": "en",
  "datePublished": "2022-12-11T15:19:56+09:00",
  "dateModified": "2022-12-11T15:19:56+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://blog.cro.sh/posts/four-years-of-rust/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Option::None",
    "logo": {
      "@type": "ImageObject",
      "url": "http://blog.cro.sh/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://blog.cro.sh/" accesskey="h" title="Option::None (Alt + H)">Option::None</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      4년간의 Rust 사용 후기
    </h1>
    <div class="post-meta"><span title='2022-12-11 15:19:56 +0900 KST'>December 11, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>2018년 중순부터 4년간 Rust를 사용해보았고, 최근 1년 반 가량은 병역특례를 하면서 프로덕션에서도 사용을 해 보았다.
연말이기도 하니, 그 동안 내가 Rust를 하면서 어떤 인상을 받았는지를 중점으로 하여 되돌아보고자 한다.</p>
<pre tabindex="0"><code class="language-nohighlight" data-lang="nohighlight">주의: 작성자의 사견이 다량 포함되어 있습니다.
</code></pre><h1 id="rust의-철학">Rust의 철학<a hidden class="anchor" aria-hidden="true" href="#rust의-철학">#</a></h1>
<p>Rust는 폭넓게 쓰이는 다른 언어들에 비해 상당히 이질적인 부분이 많다. 이러한 부분은 기능의 설계 단계에서부터
특정한 철학 혹은 규칙을 적용하여 발생하는 괴리라고 생각이 든다. 이러한 부분에 대해 이해하면 조금 더 Rust를 쉽게
배울 수 있을 것이다.</p>
<h2 id="zero-cost-abstraction">Zero-cost Abstraction<a hidden class="anchor" aria-hidden="true" href="#zero-cost-abstraction">#</a></h2>
<blockquote>
<p>The concept of zero cost abstractions originally came from the functional world.
However, the terminology comes from C++. According to Bjarne Stroustrup,</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle:
What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.
<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
</blockquote>
<p>보통 zero-cost abstraction을 두 개의 문장으로 번역하여 설명하곤 한다.</p>
<ol>
<li>사용하지 않는 기능에는 비용을 지불하지 않는다.</li>
<li>추상화한 코드의 비용이 추상화하지 않은 날것의 구현과 동일하다.</li>
</ol>
<p>1번의 예를 들어보면, Rust 언어의 주요한 요소 중 하나인 lifetime은 포인터(혹은 레퍼런스)의 유효성을 런타임이 아닌 컴파일
타임에 검증하기 위해 존재한다.</p>
<p>JavaScript를 예로 들어보자. 객체를 변수에 담는다는 것은, 사실은 특정 객체를 바라보는 레퍼런스를 변수에 담는다는 것이고,
그 객체에 직접 접근할 수는 없다. 그리고 대입(<code>=</code>) 연산을 통해 변수를 &lsquo;복제&rsquo;하여도, 새로운 객체가 복제되어 생성되는 것이
아니라 같은 객체를 바라보는 레퍼런스가 하나 더 생기는 것이다. 그러면 우리는 레퍼런스가 항상 &lsquo;살아 있는&rsquo; 객체를 바라본다는
것을 어떻게 확신할 수 있을까? 답은 역설적이게도 &lsquo;자신을 바라보는 레퍼런스가 존재하는 동안에는 객체가 항살 살아 있는다&rsquo;는
것이다.</p>
<p>다시 말해, JavaScript는 런타임에 자신을 바라보는 레퍼런스의 수, 유식한 말로
refcount를 추적하는 비용은 프로그래머의 의도와 관계없이 고정으로 지출되는 것이다. (요즘 자바스크립트 엔진은 상당한 최적화가
되어 있어서 자명한 경우에는 없앨 수도 있겠다.)</p>
<p>Rust의 경우에는 더 엄격한 규칙을 적용해서 컴파일 타임에 각각의 값들이 언제 사라져도 안전한지를 추적하고, 런타임에는
그러한 비용이 들지 않도록 설계했는데, 이 &lsquo;언제&rsquo; 시점을 lifetime이 결정한다고 보면 된다.</p>
<p>2번의 예도 들어보자. Java에서 오버라이드된 메서드를 호출할 때는 메서드의 실제 구현을 찾은 뒤에 해당 구현을 사용해야
하기에, dynamic dispatch라고 불리는 기능이 필요하다. Dynamic이라는 말이 들어간 기능답게, 이는 공짜가 아니다. JVM에서
최적화를 할 수는 있겠지만 비용을 0으로 만들 수는 없다.</p>
<p>Rust의 경우에는 (trait object를 제외하면) 모두 static dispatch를 수행한다. 다르게 말하면, 컴파일 시점에 모든 함수 호출이
어느 구현을 사용해야 하는지 알게 되는 것이다(대신 이 또한 Java에 비해 이질적이거나 경직된 설계를 유도하는 원인이 된다).</p>
<p>Zero-cost abstraction이 주는 제약도 많지만, 나는  Rust가 C++와 경쟁하며 더 나아가 수많은 플랫폼에서 실행 가능하도록
하는 데 기여했다고 생각한다. 이는 &lsquo;Rust의 장점&rsquo; 문단에서 다시 언급하겠다.</p>
<h2 id="암묵적보다는-명시적-표현을-지향">암묵적보다는 명시적 표현을 지향<a hidden class="anchor" aria-hidden="true" href="#암묵적보다는-명시적-표현을-지향">#</a></h2>
<p>C에서의 integer promotion을 기억하는가?</p>
<blockquote>
<p>If an int can represent all values of the original type (as restricted by the width, for a bit-field),
the value is converted to an int; otherwise, it is converted to an unsigned int.
These are called the integer promotions. All other types are unchanged by the integer promotions.
<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
</blockquote>
<p>대충 요약하면 C에서의 정수 연산은 손실이 일어나지 않는 한 암시적으로 각 값을 int 혹은 unsigned int로 변환 후 계산한다.</p>
<p>C가 아니더라도, Javascript의 <code>1 + 'a'</code>라던가 하는, 암시적 형변환이 가져올 수 있는 footgun이나 숨겨진 비용 문제를
제거하기 위해서 Rust는 가능한 한 명시적으로 코드를 표현하는 것을 좋아하는 것으로 보인다. 예를 들어 dynamic dispatch를
가능케 하는 trait object는 원래 trait 이름 그 자체만 쓰면 되었지만 Rust 2018부터는 dyn이라는 키워드를 앞에 붙여야
하도록 바뀌었다. 앞서 말한 타입캐스팅도 모두 <code>as</code> 키워드나 <code>try_from</code>(정보 손실이 가능한 경우에는 대부분 후자가 권장된다)
메서드를 명시적으로 사용해야만 발생한다.</p>
<h1 id="rust의-장점">Rust의 장점<a hidden class="anchor" aria-hidden="true" href="#rust의-장점">#</a></h1>
<p>내가 4년 동안, 질리지도 않고 Rust를 사용할 수 있었던 이유를 소개해보고자 한다.</p>
<h2 id="매우-강력한-타입-시스템과-이에-따라붙는-표현력">매우 강력한 타입 시스템과 이에 따라붙는 표현력<a hidden class="anchor" aria-hidden="true" href="#매우-강력한-타입-시스템과-이에-따라붙는-표현력">#</a></h2>
<p>Rust의 타입 시스템은 해결하고자 하는 문제를 모델링할 때 거슬릴 일이 없을 정도로 매우 강력하고,
타입 추론과 타입 레벨 연산 기능도 아주 훌륭해서 zero-cost abstraction을 달성하는 데에 많은 도움을 준다.
그 중에서 몇 개를 꼽아보자면&hellip;</p>
<h3 id="generics">Generics<a hidden class="anchor" aria-hidden="true" href="#generics">#</a></h3>
<p>Rust의 일반화 프로그래밍은 아주 강력해서, 다음의 기능들을 가지고 있다</p>
<ul>
<li>
<p>Trait: 타입의 &lsquo;특성&rsquo; 을 서술할 수 있다. 이 타입은 전순서를 가진다거나, 문자열로 변환 가능하다던가&hellip;
(interface처럼 다중 구현이 가능하지만 abstract class처럼 default implementation이 가능한, 중간의 무언가로
봐도 무방하다.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Ord: Eq <span style="color:#f92672">+</span> PartialOrd<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Ordering</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">min</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">clamp</span>(self, min: <span style="color:#a6e22e">Self</span>, max: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        Self: PartialOrd<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>값이 전순서를 가짐을 표현하는 Ord는, 순서 정의인 cmp만 구현하면
max, min, clamp 메서드의 default implementation이 따라온다.</p>
</li>
<li>
<p>Type bound: 타입 파라미터에 trait/lifetime 조건을 명시할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">find_max</span><span style="color:#f92672">&lt;</span>T: Ord<span style="color:#f92672">&gt;</span>(xs: <span style="color:#66d9ef">&amp;</span>[T]) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span> { <span style="color:#75715e">// T가 Ord를 구현해야 사용 가능하다
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">match</span> xs.len() {
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span> <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;xs is empty&#34;</span>),
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">&amp;</span>xs[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>      _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> max <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>xs[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> xs {
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;</span> max { <span style="color:#75715e">// 여기서 T: Ord가 필요해진다 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                  max <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>              }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          max
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>Generic trait: Trait에도 타입 파라미터를 붙일 수 있다. 가장 간단한 예시로 <code>From&lt;T&gt;</code>를 보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> From<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(T) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>어떤 타입이 <code>From&lt;T&gt;</code> 를 구현하면, T로부터 자신(<code>Self</code>)으로 자명하게 변환 가능하다는 뜻이다.</p>
</li>
<li>
<p>Associated type: Trait에 &lsquo;연관된&rsquo; 타입을 정의하여 구현하는 타입이 지정헤주도록 강제할 수 있다.
<code>From&lt;T&gt;</code>의 &lsquo;실패 가능한&rsquo; 버전인 <code>TryFrom&lt;T&gt;</code>를 보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> TryFrom<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Error</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_from</span>(value: <span style="color:#a6e22e">T</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Self, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>어떤 타입이 <code>TryFrom&lt;T&gt;</code>를 구현하려면, &lsquo;실패 가능한&rsquo; <code>T</code>로부터 오는 변환도 정의하고, 변환이 실패했을 때
반환할 리턴 타입도 지정해야 한다.</p>
</li>
<li>
<p>Generic implementation: 함수와 trait만 일반화 가능한 것이 아니라, <code>impl</code> 블록도 일반화가 가능하다.
즉 특정 조건을 만족하는 타입 모두에 대해서 다른 Trait에 대한 구현을 추가할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> Into<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> T
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    U: From<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into</span>(self) -&gt; <span style="color:#a6e22e">U</span> {
</span></span><span style="display:flex;"><span>        U::from(self)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Into&lt;U&gt;</code> 는 <code>From&lt;T&gt;</code> 의 &lsquo;역순&rsquo; trait으로, <code>T -&gt; U</code> 방향을 뒤집어서 <code>U -&gt; T</code> 방향으로 (<code>something.into()</code>와 같이)
사용 가능하도록 해 주는 trait이다(<code>From</code>이 존재하는데 <code>Into</code>가 왜 필요하냐고 의문을 가질 수 있지만, 매우 사소한(?)
이유이므로 일단 있다는 사실만 알고 가자).</p>
<p>이 <code>Into&lt;U&gt;</code>를 <code>U: From&lt;T&gt;</code>를 만족하는 U에 해당하는 각각의 타입에 대고 구현하는 것은 불가능하므로, 일반화된 <code>impl</code>을
사용하여 모든 타입에 대해 한 번에 구현하는 것이다.</p>
</li>
<li>
<p>Generic associated type: associated type도 일반화시킬 수 있다. 다시 말해 associated type도 타입 파라미터를 가질 수
있다는 것인데, 조금 복잡한 예시를 하나 들어보면:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> PointerFamily {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pointer</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>: <span style="color:#a6e22e">Deref</span><span style="color:#f92672">&lt;</span>Target <span style="color:#f92672">=</span> T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(value: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">Self</span>::Pointer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArcFamily</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> PointerFamily <span style="color:#66d9ef">for</span> ArcFamily {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pointer</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Arc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(value: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">Self</span>::Pointer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Arc::new(value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">RcFamily</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> PointerFamily <span style="color:#66d9ef">for</span> RcFamily {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pointer</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Rc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(value: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">Self</span>::Pointer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Rc::new(value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Foo</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">PointerFamily</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    bar: <span style="color:#a6e22e">P</span>::Pointer<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<p>여러 종류의 (스마트) 포인터를 PointerFamily라는 하나의 trait으로 묶어서 표현할 수 있게 된다.
포인터는 <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>와 같이 그 자체로 일반화되어있으므로 한 차원 위에서 다시 한번 일반화하는 기능이 필요한데,
이를 GAT를 사용하여 표현하는 것이다.</p>
</li>
</ul>
<p>이렇게 Rust의 강력한 일반화 프로그래밍 기능을 아래의 ADT와 조합하면,
사실상 거의 모든 문제상황을 타입으로 모델링할 수 있게 된다.</p>
<h3 id="adt-enum과-패턴-매칭">ADT: <code>enum</code>과 패턴 매칭<a hidden class="anchor" aria-hidden="true" href="#adt-enum과-패턴-매칭">#</a></h3>
<p>Algebraic Data Type의 줄임말로, 타입을 이를 만족하는 값들의 집합으로 보았을 때 집합 간의 연산 결과로 나오는
타입을 말한다. 일반적으로 &lsquo;합연산&rsquo;과 &lsquo;곱연산&rsquo;을 따지는데, 각각 Rust의 <code>enum</code>과 <code>struct</code>에 대응된다.
다시 말해, <code>enum</code>은 &lsquo;or&rsquo;, <code>struct</code>는 &lsquo;and&rsquo;를 뜻하기 때문에 표현하고 싶은 상황을 타입으로 나타내기에 매우 적합하다.</p>
<p>예를 들어, 3층짜리 찬장에 있는 세 가지 색깔의 컵이 어떻게 배치되어 있는지 알고 싶다고 하자.
찬장의 각 &lsquo;층&rsquo;은 동시에 존재하므로, &lsquo;and&rsquo; 연산인 <code>struct</code>를 이용하도록 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Cupboard</span> {
</span></span><span style="display:flex;"><span>    first: Vec<span style="color:#f92672">&lt;</span>Cup<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    second: Vec<span style="color:#f92672">&lt;</span>Cup<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    third: Vec<span style="color:#f92672">&lt;</span>Cup<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>컵의 경우에는 세 가지 색깔이 있고 동시에 두 가지 색을 가질 수는 없으므로 &lsquo;or&rsquo; 연산인 &rsquo;enum&rsquo;을 이용하면 되는 것이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Cup</span> {
</span></span><span style="display:flex;"><span>    Red,
</span></span><span style="display:flex;"><span>    Blue,
</span></span><span style="display:flex;"><span>    Green,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>더 나아가서, Rust의 enum에는 각 variant마다 값을 넣을 수 있다. 만약 찬장에 넣을 수 있는 것이 접시도 있다면?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Object</span> {
</span></span><span style="display:flex;"><span>    Cup(Cup),
</span></span><span style="display:flex;"><span>    Dish(Dish),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이번에는, 접시를 쌓아서 보관할 수도 있다면?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Object</span> {
</span></span><span style="display:flex;"><span>    Cup(Cup),
</span></span><span style="display:flex;"><span>    Dish(Dish),
</span></span><span style="display:flex;"><span>    StackedDish(Vec<span style="color:#f92672">&lt;</span>Dish<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이렇게 만들어진 enum이나 struct에서 값을 뽑아오려면, 패턴 매칭을 사용할 수 있다(struct의 경우 다른 언어와 동일하게 <code>.</code>으로
접근하는 것도 가능하다).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> object {
</span></span><span style="display:flex;"><span>  Cup(cup) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>  Dish(dish) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>  StackedDish(stacked_dish) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>각각의 match 곁가지들에서 각 variant가 담고 있는 값을 변수로 할당하여 사용 가능한 것을 알 수 있다.</p>
<p>패턴 매칭은 단순히 &lsquo;한 겹&rsquo; 벗기는 것을 넘어 중첩된 패턴에도 매칭할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> (object1, object2) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 두 값에 대해 동시에 매칭하면서, 안쪽의 값에 대해서도 한번 더 매칭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  (Cup(Cup::Red), Cup(Cup::Blue)) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 두 값에 대해 동시에 매칭하면서, 안쪽의 값을 써서 추가적인 조건 제시
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  (Cup(a), Cup(b)) <span style="color:#66d9ef">if</span> a <span style="color:#f92672">==</span> b <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> } <span style="color:#75715e">// Cup: Eq 라 가정하자.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// _ 는 항상 매칭에 성공하는 값이다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  (Dish(dish), _) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>  (StackedDish(stacked_dish), _) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 위의 패턴들 중 아무것도 만족하지 않으면...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  _  <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>조금 더 현실적인 enum의 예시로는, 에러 핸들링의 중추가 되는 <code>Result&lt;T, E&gt;</code> 타입이 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Ok(T),
</span></span><span style="display:flex;"><span>    Err(E)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>(여기서 알 수 있겠지만 enum이나 struct도 일반화할 수 있다.)</p>
<h2 id="높은-런타임-성능">높은 런타임 성능<a hidden class="anchor" aria-hidden="true" href="#높은-런타임-성능">#</a></h2>
<p>Rust의 zero-cost abstraction 덕분에, Rust 프로그램은 얼마든지 필요한 만큼만 사용하는 &lsquo;가벼운&rsquo; 코드를 작성할 수 있다(주의:
약간의 예외 있음). 이는 높은 범용성과도 맞물리는데, 좀 더 아래에서 서술하겠다.</p>
<h3 id="zero-cost-asynchronous-programming">Zero-cost Asynchronous Programming<a hidden class="anchor" aria-hidden="true" href="#zero-cost-asynchronous-programming">#</a></h3>
<p>Rust에서 제일 강력한 기능 중 하나를 꼽으라면, 나는 망설임 없이 <code>async</code>/<code>await</code>을 선택할 것이다.
다른 언어에서 구현하는 비동기 프로그래밍과는 약간의 차이가 있지만(체계 자체가 조금 더 명시적이다),
손으로 state machine을 짜서 구현한 것과 대등한 성능을 보이며<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> GC가 필요없는 언어 중에서는 Rust가
독보적으로 편의성과 안전성 면에서 우위를 점하고 있다.</p>
<p>특히 이는 대규모 네트워크 서비스를 제공하는 기업에서 저지연, 고부하 조건을 만족해야 할 때 크게 작용하는데,
Discord는 <a href="https://discord.com/blog/why-discord-is-switching-from-go-to-rust">GC로 인한 지연시간 편차로 인해 Rust로 특정 마이크로서비스를 재작성하여 큰 성능 향상을
얻었고</a>, CloudFlare는 <a href="https://blog.cloudflare.com/how-we-built-pingora-the-proxy-that-connects-cloudflare-to-the-internet">내/외부망을 연결하는 프록시를
NGINX에서 자체 Rust 구현으로 교체하여 CPU 자원을 더 효율적으로 사용하기도
했다</a>.
덤으로 얻는 memory safety 덕에 CloudFlare는
<strong>수백조 단위의</strong> 요청을 처리히면서 단 한번의 프록시 버그로 인한 크래시도 경험하지 않았다고 한다. 오히려 하드웨어 문제와
알려지지 않은 <a href="https://lkml.org/lkml/2022/3/15/6">리눅스 커널의 버그</a>를 찾기까지 했다고&hellip;</p>
<h2 id="개발-도구의-성숙함">개발 도구의 성숙함<a hidden class="anchor" aria-hidden="true" href="#개발-도구의-성숙함">#</a></h2>
<p>개인적으로 Visual Studio보다는 한 수 아래라고 생각하지만, 다른 &lsquo;신생&rsquo; 언어들과 비교하면 독보적인 1순위를 달리고 있지
않나 생각한다. 빌드 시스템과 의존성 관리 역할을 해 주는 <code>cargo</code>는 다른 언어에서 벤치마킹할 정도로<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>
Rust의 장점 중 하나로 꼽히고, Rust 툴체들의 버전 관리 및 설치를 도와주는 <code>rustup</code>도 매우 편리하다.
LSP 구현체인 <code>rust-analyzer</code> 덕분에 LSP 클라이언트가 내장된 많은 에디터에서 IDE와 비슷한 경험을 가질 수도 있다.</p>
<h2 id="memory-safety">Memory Safety<a hidden class="anchor" aria-hidden="true" href="#memory-safety">#</a></h2>
<p>앞서 말한 zero-cost abstraction을 통해 궁극적으로 Rust는 &lsquo;memory safety&rsquo;를 달성한다. Rust에서 unsafe 코드를 사용하지
않는 한, 컴파일되는 모든 코드는 <strong>메모리 버그를 일으키지 않음이 보장된다</strong>. 아주 가끔씩 safe 코드만으로 undefined
behavior를 만들어낼 수 있는 구멍이 발생하지만(soundness hole), 그러한 동작들은 명백히 버그로 규정되어 최우선적으로
수정된다.</p>
<h2 id="범용성">범용성<a hidden class="anchor" aria-hidden="true" href="#범용성">#</a></h2>
<p>위에서 계속 언급했듯이, Rust 코드는 수많은 플랫폼에서 구동되고 있다.</p>
<ul>
<li>데스크탑 및 스마트폰 OS의 컴포넌트와 같은 시스템 라이브러리
<ul>
<li>Windows, Linux, MacOS, Android, iOS</li>
</ul>
</li>
<li>고성능 웹 백엔드</li>
<li>Linux Kernel 드라이버 (&gt;= 6.1)</li>
<li>eBPF 및 WebAssembly</li>
<li>블록체인(블록체인 노드, 스마트 컨트랙트 구현 등에 모두 쓰인다).</li>
<li>임베디드 프로그래밍(이 쪽은 비교적 생태계가 약하다)</li>
</ul>
<p>이것이 가능한 이유는 Rust가 근본적으로 zero-cost abstraction을 지향하기 때문에, 다른 플랫폼에 올려놓아도
추가적인 비용이 거의 발생하지 않기 때문이다. 예를 들어 Javascript를 eBPF 위에 올리려 하면, 가비지 컬렉션이나
약한 동적 타입 시스템의 비용이 필연적으로 따라오게 될 것이다. (AssemblyScript와 같이 파편화된 생태계가 발생할 수도 있다).</p>
<h1 id="rust의-단점">Rust의 단점<a hidden class="anchor" aria-hidden="true" href="#rust의-단점">#</a></h1>
<p>여기까지만 보면 Rust는 &lsquo;완전한&rsquo; 언어 같지만, 그렇지 않다. Rust를 사용해보면서 그러한 결점들을 크게 체감할 수 있었다.</p>
<h2 id="높은-진입-장벽">높은 진입 장벽<a hidden class="anchor" aria-hidden="true" href="#높은-진입-장벽">#</a></h2>
<p>Rust는 어려운 문제를 쉽게 추상화하지 않는다(쉽게 추상화하면 반드시 비용이 발생하는 지점이 있기 때문이다)<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>.</p>
<p>예를 들어, Rust에서 문자열 처리를 하고 싶으면 다음의 타입들에 대해 이해할 필요가 있다:</p>
<ul>
<li>
<p><code>String</code> (힙에 할당된 UTF-8 문자열)</p>
</li>
<li>
<p><code>&amp;str</code> (문자열 &lsquo;슬라이스&rsquo;. UTF-8로 표현된 바이트열을 바라보는 레퍼런스)</p>
<pre tabindex="0"><code class="language-nohighlight" data-lang="nohighlight">&amp;String은 거의 사용되지 않고, 대부분의 경우에 &amp;str을 사용하는 것이 권장된다.
</code></pre></li>
<li>
<p><code>&amp;[u8]</code> (바이트열. 그 자체로 문자열은 아니지만 파싱 전에 만날 확률이 높다)</p>
</li>
<li>
<p><code>Cow&lt;str&gt;</code> (&lsquo;Copy-on-Write&rsquo; 문자열. 복사를 최소화하고 싶을 때 만날 수 있다)</p>
</li>
<li>
<p><code>impl AsRef&lt;str&gt;</code> (그 자체로 타입은 아니지만, <code>&amp;str</code>과 <code>String</code>을 동시에 처리하고 싶을 때 사용할 수 있다)</p>
</li>
</ul>
<p><code>OsString</code>, <code>CString</code>, <code>Path</code>와 같이 특수한 목적을 지닌 타입들을 거론하지 않았는데도 벌써 공부할 것이 산더미가 되었다.
다른 언어들은 모르는 부분을 배제하고 쉬운 길로 (비용을 지불하고)나아갈 수 있지만, Rust의 경우에는 그것을 허용하지 않아
학습자를 좌절시키는 경우가 허다하다.</p>
<p>물론 Rust도 &lsquo;쉬운 길&rsquo;을 택하는 방법이 존재하지만, 대부분의 실전 코드들은 그렇지 않기 때문에 어떻게 비용을 지불하는지조차도
알기 어려운 경우가 많다.</p>
<h2 id="설계의-제약">설계의 제약<a hidden class="anchor" aria-hidden="true" href="#설계의-제약">#</a></h2>
<p>일반화 프로그래밍과 ADT를 찬양했다가 제약이 있다고 하면 모순되지 않냐고 할 수도 있지만, Rust의 타입 시스템이
&lsquo;인전하며 비용 없이&rsquo; 표현하는 것이 불가능한 구조도 있다. 자기참조/순환참조 구조가 그것인데, lifetime의 존재로 인해 모든 Rust의
값들 간의 참조 관계는 DAG(방향 있고 순환 없는 그래프)로 표현될 수밖에 없다. 순환 참조가 발생하는 순간 lifetime을
정의할 수 없기 때문에 컴파일에 실패한다.</p>
<p>물론 <code>Arc::new_cyclic</code> 과 같이 순환참조를 가능케 하는 도구들도 있으나, weak pointer를 사용한다던가 하는 식으로
추가적인 비용(메모리 할당 포함)을 지불하거나, <code>Pin::new_unchecked</code>를 써서 unsafe하게 작성해야 한다.
(후자는 <a href="https://docs.rs/ouroboros"><code>ouroboros</code></a>라는 crate가 자기참조를 편하게 구성할 수 있도록 해 준다고 하는데,
직접 써보지는 않아서 언급하지는 않겠다.)</p>
<p>대부분의 경우에는 이러한 구조가 필요하지 않도록 설계하는 것이 최선인데, 다른 언어를 사용하다 진입한 초심자 입장에서는
어려울 수밖에 없다. C/C++/Java 등으로 작성된 프로그램을 한줄 한줄(line-by-line) 번역해 이식하는 것이 불가능해지기 때문이다.
그러한 언어들에서는 자기참조나 순환참조 구조가 나타나는 패턴이 종종 보이곤 한다. (링크드 리스트라던가, 양방향 그래프라던가)</p>
<pre tabindex="0"><code class="language-nohighlight" data-lang="nohighlight">자기참조가 아니더라도, Rust의 borrow checker와 궁합이 맞지 않는 패턴들이 여럿 존재하는데, 예를 들어
이벤트 리스너와 callback이 주가 되는 옵저버 모델의 경우 callback이 사용하는 값들의 생명주기를 컴파일 타임에 추적하는
것이 힘들기 때문에 추가적인 할당이나 레퍼런스 카운팅이 필요해지게 될 것이다.
</code></pre><p>물론 이러한 부분에 대해서만 주의 깊게 unsafe 코드를 작성하거나 비용을 지불하여 모듈화하는 식으로 격리할 수는
있지만(Rust의 표준 라이브러리에서도 링크드 리스트와 이진 트리를 제공한다.)
Rust가 의도하는 이상이 항상 현실에 100% 적용될 수는 없다는 사실을 인지해야 한다.</p>
<p>그리고 이러한 &lsquo;격리&rsquo; 작업에 unsafe를 쓰는 경우 &lsquo;올바르게&rsquo; 마무리하는 것이 아주 어려운 것으로 평가된다.
Rust의 memory safety 등이 제공하는 보장의 특성상, 지켜야 하는 규칙이 엄격하고 이를 위반할 시에 컴파일러의 공격적인
최적화로 인한 오작동이 더 큰 문제를 일으킬 수 있기 때문이다.</p>
<h2 id="비교적-낮은-생산성개발-속도">비교적 낮은 생산성(개발 속도)<a hidden class="anchor" aria-hidden="true" href="#비교적-낮은-생산성개발-속도">#</a></h2>
<p>숙련된 Rust 프로그래머도 lifetime, borrow checker, type checker와 씨름하는 일이 자주 발생한다. 빠르게 구현해서 내보내는
프로세스가 정립된 B2C 서비스들을 운영하는 기업의 경우에는 Rust를 도입했을 때 개발 속도가 비교적 떨어질 수도
있음을 명심해야 한다.</p>
<pre tabindex="0"><code class="language-nohighlight" data-lang="nohighlight">사견으로, 이는 Go가 웹 백엔드 분야에서 크게 유행한 이유와 거의 정반대되는데, Go는 복잡한 문제도 비용을 내고
쉽게 추상화하며, 타입 시스템에 별다른 기능이 없고(1.18에야 일반화 프로그래밍이 정식으로 추가되었다), 다른 기능도
많지 않아 진입장벽이 매우 낮기 때문에 높은 생산성을 기대할 수 있다.
</code></pre><h2 id="매크로">매크로<a hidden class="anchor" aria-hidden="true" href="#매크로">#</a></h2>
<p>이 기능은 Rust에서 무제한에 가까운 메타프로그래밍을 할 수 있게 해주는 강력한 도구이지만,
개인적으로는 썩 좋아하지 않기 때문에 여기서 서술하고자 한다.</p>
<p>첫 번째로, 매크로는 문법 토큰 트리를 받아서 특정 작업을 수행하여 새로운 문법 트리를 반환하는 규칙이라고 말할 수 있는데,
설명에서도 유추할 수 있듯이 기존의 Rust 지식과는 판이한, Rust의 문법 구조에 관한 지식을 습득해야만 사용 가능하다.
다시 말해, 매크로는 사실상 Rust 문법만 차용한 또다른 Rust 안의 미니 언어로서 기능한다는 점에서 개발 경험의 괴리를 발생시킨다.
(이 단점은 두 가지 종류의 매크로 정의 방식인 procedural macro와 declarative macro에 모두 해당된다.)</p>
<p>두 번째로, proc-macro는 매크로를 적용하려는 코드 이전에 컴파일되어야 하기 때문에 전체적인 컴파일 시간을 증가시킨다.
특히 이는 소스코드만을 압축해서 올리는 Rust의 crate 시스템과 맞물려 문제를 가중시키는데, proc-macro를 미리 컴파일한
결과를 게시할 수 없기 때문이다.
(관련하여 <a href="https://github.com/dtolnay/watt"><code>watt</code></a>라는 실험적인 WebAssembly 기반
proc-macro 런타임이 있지만 메인스트림에 들어오기는 아직 곤란하다.)</p>
<p>세 번째로, IDE와 proc-macro 간의 조화가 좋은 편은 아니라 proc-macro를 지나치게 많이 사용하는 경우 개발 경험이 오히려
감소하게 되는 경우가 발생할 수 있다.</p>
<p>&lsquo;전통적인&rsquo; 매크로 정의 방법인 &lsquo;decl-macro&rsquo;, 다른 말로 macros by example 방식은 상술한 두 번째와 세 번째
문제에 대해 비교적 자유롭지만, proc-macro보다도 더 이질적인 문법과 정의 방식을 가지고 있고(간단히 설명하면,
Rust 코드의  문법 구조에 대해 패턴 매칭을 시도한다), 표현 가능한 범위에도 제약이 있어서 기능의 복잡도가 특정 지점을
넘으면 사용할 수 없게 된다. (그 예시로, 동일한 기능을 수행하는 <a href="https://github.com/taiki-e/pin-project"><code>pin-project</code></a>와
<a href="https://github.com/taiki-e/pin-project"><code>pin-project-lite</code></a>를 보면 전자는 proc-macro, 후자는 macros by example 방식인데
후자는 전자의 일부 기능을 제거했음에도 불구하고 훨씬 더 이해하기 어렵다).</p>
<h2 id="마이너리티">마이너리티<a hidden class="anchor" aria-hidden="true" href="#마이너리티">#</a></h2>
<p>Rust 구인/구직 시장은 Go와 비교해서도 매우 좁다. 특히 한국은 격차가 훨씬 심하다.</p>
<h1 id="결론-10년-뒤에도-rust로-밥벌이가-가능할까">결론: 10년 뒤에도 Rust로 밥벌이가 가능할까?<a hidden class="anchor" aria-hidden="true" href="#결론-10년-뒤에도-rust로-밥벌이가-가능할까">#</a></h1>
<p>단점을 줄줄이 나열했지만 답은 &lsquo;yes&rsquo;라고 생각한다. 내가 생각하는 현재(그리고 근미래)의 Rust 사용처는 다음과 같다.</p>
<h2 id="대규모-서비스의-백엔드">대규모 서비스의 백엔드<a hidden class="anchor" aria-hidden="true" href="#대규모-서비스의-백엔드">#</a></h2>
<p>현재로서는, 감히 말하건데 다음의 상황에서 Rust를 이길 대안은 없다.</p>
<ul>
<li>대규모 서비스를 운영하여 높은 워크로드를 가지고</li>
<li>I/O가 매우 잦으며</li>
<li>불특정 다수에게 서비스(B2C)하여 강건성을 특히 신경써야 하는</li>
</ul>
<p>(이들 중 두 개만 해당되어도 아주 매력적인 선택이 된다)</p>
<p>흔히 말하는 &lsquo;빅테크&rsquo; 백엔드 분야에서는 Rust의 zero-cost abstraction, <code>async</code>/<code>await</code>, memory safety는 독보적인
매력을 가진다. 한 가지 문제점은 이러한 매력이 비교적 작은 조직에서는 어필되기 어렵다는 점이다.</p>
<h2 id="크로스플랫폼-비즈니스-로직-모듈">크로스플랫폼 비즈니스 로직 모듈<a hidden class="anchor" aria-hidden="true" href="#크로스플랫폼-비즈니스-로직-모듈">#</a></h2>
<p>Rust의 표현력과 범용성은 여러 플랫폼에서 공유되어야 하는 비즈니스 로직을 작성할 때 큰 이점이 된다.
rustc의 <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">타깃 목록</a>을 보면, 주로 사용되는 PC/모바일
플랫폼들은 모두 Tier 1/2에 들어가 있는 것을 볼 수 있다. 즉 Rust 코드를 각 플랫폼에 대해 네이티브로 빌드하여 사용하여도 무방하다.
또한 <a href="https://github.com/rust-lang/rust-bindgen"><code>rust-bindgen</code></a>, <a href="https://github.com/eqrion/cbindgen"><code>cbindgen</code></a>
등을 사용하면 C FFI를 통해 플랫폼 고유 코드와 소통하는 데에도 어려움이 없다.</p>
<p>이 부분은 <a href="https://www.slideshare.net/utilforever/2022-rust">인프콘 2022에서 크로스플랫폼 Rust를 발표한 자료</a>를
참고하면 좋을 것으로 보인다.</p>
<h2 id="ffi로-호출-가능한-고성능-연산-모듈">FFI로 호출 가능한 고성능 연산 모듈<a hidden class="anchor" aria-hidden="true" href="#ffi로-호출-가능한-고성능-연산-모듈">#</a></h2>
<p>최근에 알게 되어 아직 검토가 부족하지만 불확실함을 무릅쓰고 여기에 주장을 남겨 보면, Rust의 비교적 경직된 설계를
최소화할 수 있는 방법으로 동적 스크립팅 언어와의 바인딩으로 사용하는 방법이 유효할 것으로 생각된다.
예를 들어, Python에 쉽게 Rust 코드를 붙일 수 있는 <a href="https://pyo3.rs">PyO3</a>나, Ruby 익스텐션을 쉽게 만들 수 있는
<a href="https://github.com/matsadler/magnus">Magnus</a> 등을 사용하여 스크립팅을 위주로 작성하되 병목 지점에서
Rust로 작성한 모듈을 사용하여 고성능을 꾀하는 방식이다. 개인적으로는 LuaJIT과의 연동에 관심이 있는데,
<a href="https://github.com/khvzak/mlua">mlua</a>라는 crate가 있어 주의깊게 지켜보고 있다.</p>
<h1 id="마무리">마무리<a hidden class="anchor" aria-hidden="true" href="#마무리">#</a></h1>
<p>Rust를 선도적으로 도입한 사례들에서 알 수 있듯이, 소수의 빅테크 회사들을 시작으로 한 Rust의 물결은 이제 부정하기
어렵게 되었다. 상술하였듯이 Rust가 모든 상황에서 만능으로 사용 가능한 은탄환이 될 수는 없는 걸 알면서도, Rust를
좋아하는 개발자 입장에서는 Rust가 지금보다 훨씬 폭넓은 범위에서 사용되었으면 하는 바램이 있다. 앞으로도 Rust를 써서 좋아하는
일을 할 수 있기를 기대하며 부족한 회고록을 마치도록 하겠다.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://stackoverflow.com/a/73518476">https://stackoverflow.com/a/73518476</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://stackoverflow.com/a/44456310">https://stackoverflow.com/a/44456310</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://rust-lang.github.io/rfcs/1598-generic_associated_types.html#associated-type-constructors-of-type-arguments">https://rust-lang.github.io/rfcs/1598-generic_associated_types.html#associated-type-constructors-of-type-arguments</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="http://aturon.github.io/tech/2016/08/11/futures">http://aturon.github.io/tech/2016/08/11/futures</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><a href="https://github.com/python-poetry/poetry/tree/c5c7624ef64f34d9f50c3b7e8118f7f652fddbbd#why">https://github.com/python-poetry/poetry/tree/c5c7624ef64f34d9f50c3b7e8118f7f652fddbbd#why</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p><a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride#parting-words">https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride#parting-words</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>© 2019-2021 Nam Junghyun</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "152863abaa9948f9bb84e53ef4204e47"}'></script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
