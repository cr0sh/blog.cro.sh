<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Demystifying Functional Effect Systems in Rust (Part 1) | Option::None</title>
<meta name="keywords" content="">
<meta name="description" content="Effect system을 공부하던 중, Demystifying Functional Effect Systems in Scala라는 좋은 글을 접했다. Rust에서 effect system을 적용하면 어떤 모습이 될 지 궁금하여, 해당 글을 한국어로 간단히 요약하면서 Rust로 코드를 옮겨보았다.">
<meta name="author" content="">
<link rel="canonical" href="http://blog.cro.sh/posts/demystifying-functional-effect-systems-in-rust-part-1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://blog.cro.sh/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://blog.cro.sh/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://blog.cro.sh/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://blog.cro.sh/apple-touch-icon.png">
<link rel="mask-icon" href="http://blog.cro.sh/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="http://blog.cro.sh/css/allow-horizontal-highlight-scroll.css"><link rel="stylesheet" href="http://blog.cro.sh/css/small-page-heading.css"><link rel="stylesheet" href="http://blog.cro.sh/css/fix-ios-hljs.css"><meta property="og:title" content="Demystifying Functional Effect Systems in Rust (Part 1)" />
<meta property="og:description" content="Effect system을 공부하던 중, Demystifying Functional Effect Systems in Scala라는 좋은 글을 접했다. Rust에서 effect system을 적용하면 어떤 모습이 될 지 궁금하여, 해당 글을 한국어로 간단히 요약하면서 Rust로 코드를 옮겨보았다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.cro.sh/posts/demystifying-functional-effect-systems-in-rust-part-1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-29T19:21:34+09:00" />
<meta property="article:modified_time" content="2023-05-29T19:21:34+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Demystifying Functional Effect Systems in Rust (Part 1)"/>
<meta name="twitter:description" content="Effect system을 공부하던 중, Demystifying Functional Effect Systems in Scala라는 좋은 글을 접했다. Rust에서 effect system을 적용하면 어떤 모습이 될 지 궁금하여, 해당 글을 한국어로 간단히 요약하면서 Rust로 코드를 옮겨보았다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://blog.cro.sh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Demystifying Functional Effect Systems in Rust (Part 1)",
      "item": "http://blog.cro.sh/posts/demystifying-functional-effect-systems-in-rust-part-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Demystifying Functional Effect Systems in Rust (Part 1)",
  "name": "Demystifying Functional Effect Systems in Rust (Part 1)",
  "description": "Effect system을 공부하던 중, Demystifying Functional Effect Systems in Scala라는 좋은 글을 접했다. Rust에서 effect system을 적용하면 어떤 모습이 될 지 궁금하여, 해당 글을 한국어로 간단히 요약하면서 Rust로 코드를 옮겨보았다.\n",
  "keywords": [
    
  ],
  "articleBody": "Effect system을 공부하던 중, Demystifying Functional Effect Systems in Scala라는 좋은 글을 접했다. Rust에서 effect system을 적용하면 어떤 모습이 될 지 궁금하여, 해당 글을 한국어로 간단히 요약하면서 Rust로 코드를 옮겨보았다.\n프로그래밍 언어 이론을 공부하는 초심자의 시선에서 작성했기 때문에 내용에 부정확한 점이나 오역이 있을 수 있습니다. 이메일 hyun@cro.sh 로 연락 주시면 정정하겠습니다. 감사합니다.\n1장: 이펙트 생성하고 조합하기 이펙트는 일반적으로 IO 모나드의 개념에서 출발한다. IO 모나드는 인자 없는 함수를 감싸 효과(이펙트)를 (필요하면) 만들어내고 반환값을 생성해내는 객체1다. 모나드가 됨으로서 여러 개의 ‘감싸진’ (혹은 일시정지된) 이펙트가 합성되어 이펙트들의 순차적 실행을 표현할 수 있게 된다.\n참고로, 일반적인 모나드에 대한 설명은 이 글에서 다루지 않으나, 이러한 개념을 이해하는 것은 이 글을 따라가는 데 상당히 중요할 것이다.\n기본적인 IO 모나드는 아마도 다음과 같은 trait으로 정의할 수 있을 텐데, ToyIo::effect 생성자(대개 pure라는 이름으로도 불려짐)를 통해 실존하는 ’toy’ 구현체를 생성할 수 있게 된다(아직 세부적인 구현은 이루어지지 않음).\npub trait IoExt: Io + Sized { fn flat_map\u003cR: Io, F: FnOnce(Self::Success) -\u003e R\u003e(self, f: F) -\u003e FlatMap\u003cSelf, F\u003e; fn map\u003cS, F: FnOnce(Self::Success) -\u003e S\u003e(self, f: F) -\u003e Map\u003cSelf, F\u003e; } impl\u003cT: Io\u003e IoExt for T { fn flat_map\u003cR: Io, F: FnOnce(Self::Success) -\u003e R\u003e(self, f: F) -\u003e FlatMap\u003cT, F\u003e { FlatMap { inner: self, func: f, } } fn map\u003cS, F: FnOnce(Self::Success) -\u003e S\u003e(self, f: F) -\u003e Map\u003cT, F\u003e { Map { inner: self, func: f, } } } // ToyIo는 Io를 구현하는 어떠한 구조체 타입이다. 자세한 구현은 뒤에 나온다. pub struct ToyIo\u003cT\u003e(T); impl\u003cT, F: FnOnce() -\u003e T\u003e ToyIo\u003cF\u003e { pub fn effect(f: F) -\u003e Self { Self(f) } } 2\n실제 코드에서는 flat_map, map을 IoExt extension trait으로 구현하었고 뒤따라오는 코드들에서도 해당 구현을 기반으로 작성될 예정이다.\n이제 우리는 IO로 감싸진 이펙트들을 조합해 어떤 프로그램이든 만들어낼 수 있다:\nfn program() { use std::io::{self, BufRead}; ToyIo::effect(|| println!(\"what's your name?\")) .flat_map(|()| { ToyIo::effect(|| { let mut stdin = io::stdin().lock(); let mut buf = String::new(); stdin.read_line(\u0026mut buf).expect(\"cannot read\"); buf }) }) .map(|name| ToyIo::effect(move || println!(\"hello, {name}!\"))) .run(); } 원문에서는 Scala의 for comprehension을 사용했으나 Rust에는 그러한 문법 설탕이 존재하지 않으므로 직접 desugaring하였다. 이는 Rust에서 이펙트 시스템을 적극적으로 채용하려면 proc-macro 등으로 문법을 확장하거나 컴파일러에서 문법 설탕을 지원해줘야 함을 함의한다.\nToyIo 구현 이제 ToyIo 모나드를 본격적으로 구현해보자. ToyIo는 ZIO3의 API를 얼추 따르지만 typed error나 environment같은 기능은 단순함을 위해 제외되었다.\nimpl\u003cT, F: FnOnce() -\u003e T\u003e Io for ToyIo\u003cF\u003e { type Success = T; fn run(self) -\u003e Self::Success { todo!() } } pub struct FlatMap\u003cT, F\u003e { inner: T, func: F, } impl\u003cT: Io, R: Io, F: FnOnce(T::Success) -\u003e R\u003e Io for FlatMap\u003cT, F\u003e { type Success = R::Success; fn run(self) -\u003e Self::Success { todo!() } } pub struct Map\u003cT, F\u003e { inner: T, func: F, } impl\u003cT: Io, S, F: FnOnce(T::Success) -\u003e S\u003e Io for Map\u003cT, F\u003e { type Success = S; fn run(self) -\u003e Self::Success { todo!() } } 4\n코드가 원문에 비해 훨씬 장황한 이유는, 타입-레벨 프로그래밍과 정적 디스패치를 사용해 런타임 비용을 없애고자, 각 trait method의 리턴형을 독립된 타입으로 정의하였기 때문이다. 동적 디스패치로 처리한 코드는 그렇게 복잡하지 않다:\npub trait Io { type Success; fn flat_map\u003cR: Io, F: FnOnce(T) -\u003e R\u003e(self, f: F) -\u003e R::Success; fn map\u003cS, F: FnOnce(T) -\u003e S\u003e(self, f: F) -\u003e S; fn run(self) -\u003e T; } pub struct ToyIo\u003cT\u003e(Box\u003cdyn FnOnce() -\u003e T\u003e); impl\u003cT\u003e ToyIo\u003cT\u003e { pub fn effect\u003cF: FnOnce() -\u003e T + 'static\u003e(f: F) -\u003e Self { Self(Box::new(f)) } } impl\u003cT\u003e Io for ToyIo\u003cT\u003e { type Success = T; fn flat_map\u003cR: Io, F: FnOnce(T) -\u003e R\u003e(self, f: F) -\u003e R::Success { todo!() } fn map\u003cS, F: FnOnce(T) -\u003e S\u003e(self, f: F) -\u003e S { todo!() } fn run(self) -\u003e T { todo!() } } 또한, 원문에서는 TIO.succeed()를 활용해 map의 구현을 flatMap으로 넘기고 있지만, Rust에서는 그렇게 하면 익명 함수의 타입 파라미터를 만들어낼 수 없기 때문에 불가능하다. RPITIT(return-position-impl-trait-in-trait)이 안정화되지 않는 한 각각 구현하는 것이 최선이라고 판단하였다.\nToyIo와 FlatMap, Map은 이펙트가 어떻게 실행되어야 하는지를 정의한다. 이 정의는 가끔 ‘대수’로 불리기도 한다. (작성자 주: ‘대수적 이펙트’의 그 ‘대수’인 것으로 보인다.)\n엄밀히 원문의 Scala case class를 사용한 코드를 Rust로 옮기면 열거형으로 FlatMap과 Map을 표현했어야 하나, zero-cost를 강조하기 위해 각각을 구조체로 표현하고 타입 레벨 프로그래밍을 도입하였다.\n이제 이 ToyIo와 친구들의 실행 방법을 정의할 차례이다.\nuse std::error::Error; type BoxError = Box\u003cdyn Error + Send + Sync + 'static\u003e; pub trait Run: Io { fn eval(self) -\u003e Result\u003cSelf::Success, BoxError\u003e; } impl\u003cT, F: FnOnce() -\u003e T\u003e Run for ToyIo\u003cF\u003e { fn eval(self) -\u003e Result\u003cSelf::Success, BoxError\u003e { Ok(self.0()) } } impl\u003cT: Run, R: Run, F: FnOnce(T::Success) -\u003e R\u003e Run for FlatMap\u003cT, F\u003e { fn eval(self) -\u003e Result\u003cSelf::Success, BoxError\u003e { (self.func)(self.inner.eval()?).eval() } } impl\u003cT: Run, S, F: FnOnce(T::Success) -\u003e S\u003e Run for Map\u003cT, F\u003e { fn eval(self) -\u003e Result\u003cSelf::Success, BoxError\u003e { Ok((self.func)(self.inner.eval()?)) } } 엄밀히 따지면, 에러를 박싱함으로서 zero-cost에서 벗어났다고도 할 수 있다. 그러나 에러 처리 자체를 zero-cost로 구현하는 것에 집중하기보다는(필자가 생각하는 선에서는 완벽한 zero-cost 에러 처리를 타입 레벨 프로그래밍으로 구현할 수는 없을 것 같다) effect system을 구현하는 것에 집중하는 것이 옳다는 판단 하에 에러를 박싱하였다.\n이제 ToyIo를 실제로 사용해보자. 그러기 위해서는 ToyIo를 실행해줄 실행기가 필요하다.\npub fn unsafe_run_sync\u003cR: Run\u003e(r: R) -\u003e Result\u003cR::Success, Box\u003cdyn Error + Send + Sync + 'static\u003e\u003e { r.eval() } fn sequence_effects() { let effect = ToyIo::effect(|| println!(\"running first effect\")) .flat_map(|()| ToyIo::effect(|| println!(\"running second effect\"))); unsafe_run_sync(effect).expect(\"cannot unsafe_run_sync\"); } running first effect running second effect 원문에서는 unsafe_run_sync이 eval().unwrap()을 수행하는 것에 가까우나 이는 idiomatic Rust에서 멀어지게 되므로 지양하였다.\n1장의 전체 코드는 https://github.com/cr0sh/demystifying-functional-effect-systems-in-rust/blob/master/iteration1/src/lib.rs 에 있다.\n2장: 에러로부터 복구하기 에러 핸들링을 지원하기 위해, 어떻게 이펙트의 실패를 표현할 수 있을지 알아보자.\npub struct ToyIoFail\u003cE\u003e(E); impl\u003cE\u003e ToyIoFail\u003cE\u003e { pub fn fail(e: E) -\u003e Self { Self(e) } } impl\u003cE\u003e Io for ToyIoFail\u003cE\u003e { type Success = Never; // #[feature(never_type)] 이 안정화되면 `!`일 것이다. } impl\u003cE: Error + Send + Sync + 'static\u003e Run for ToyIoFail\u003cE\u003e { fn eval(self) -\u003e Result\u003cSelf::Success, BoxError\u003e { Err(Box::new(self.0)) } } #[derive(Debug, Clone, Copy)] pub enum Never {} 이제 실패한 이펙트의 복구 방법도 알아보자:\npub trait IoExt: Io + Sized { // ... fn recover\u003cU: Io\u003cSuccess = Self::Success\u003e, F: FnOnce(BoxError) -\u003e U\u003e( self, f: F, ) -\u003e Recover\u003cSelf, F\u003e; } impl\u003cT: Io\u003e IoExt for T { // ... fn recover\u003cU: Io\u003cSuccess = T::Success\u003e, F: FnOnce(BoxError) -\u003e U\u003e( self, f: F, ) -\u003e Recover\u003cSelf, F\u003e { Recover { inner: self, func: f, } } } pub struct Recover\u003cT, F\u003e { inner: T, func: F, } impl\u003cT, S: Io\u003cSuccess = T\u003e, U: Io\u003cSuccess = T\u003e, F: FnOnce(BoxError) -\u003e U\u003e Io for Recover\u003cS, F\u003e { type Success = T; } impl\u003cT, S: Run\u003cSuccess = T\u003e, U: Run\u003cSuccess = T\u003e, F: FnOnce(BoxError) -\u003e U\u003e Run for Recover\u003cS, F\u003e { fn eval(self) -\u003e Result\u003cSelf::Success, BoxError\u003e { match self.inner.eval() { Ok(x) =\u003e Ok(x), Err(e) =\u003e (self.func)(e).eval(), } } } 이제 실제로 이를 사용해 오류를 복구해보자.\nuse std::{error::Error, fmt::Display}; use super::*; #[derive(Debug)] struct StrError(\u0026'static str); impl Display for StrError { fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result { write!(f, \"{}\", self.0) } } impl Error for StrError {} fn fail_and_recover() { let effect = ToyIo::effect(|| println!(\"running first effect\")) .flat_map(|()| ToyIoFail::fail(StrError(\"some error\"))) .flat_map(|_| ToyIo::effect(|| println!(\"second effect - will not run\"))) .recover(|e| ToyIo::effect(move || println!(\"recovered from failure: {e}\"))); unsafe_run_sync(effect).expect(\"cannot execute\"); } running first effect recovered from failure: some error 여기까지만 해도 충분히 강력하지만, 우리의 ToyIo 예제는 두 가지 문제점이 있다:\n비동기를 지원하지 않는다. Stack-safe하지 않다. 두 번쩨 포인트를 짚어보자면, 우리의 구현은 재귀에 의존하기 때문에 타입의 깊이가 깊어지면 그만큼 재귀의 깊이도 깊어진다.\npub struct ToyIoForEach\u003cI, F\u003e { it: I, func: F, } impl\u003cI, F\u003e ToyIoForEach\u003cI, F\u003e { pub fn for_each(it: I, f: F) -\u003e Self { Self { it, func: f } } } impl\u003cItem, I: Iterator\u003cItem = Item\u003e, R: Io, F: FnMut(Item) -\u003e R\u003e Io for ToyIoForEach\u003cI, F\u003e { type Success = Vec\u003cR::Success\u003e; fn eval(self) -\u003e Result\u003cSelf::Success, BoxError\u003e { self.it .fold(ToyIo::effect(|| Vec::new()), |acc, curr| { // mismatched types IoExt::flat_map(acc, |x| { (self.func)(curr).map(|y| { let mut z = x; z.push(y); z }) }) }) .eval() } } Checking iteration2 v0.1.0 (/Users/namjh/dev/personal/demystifying-functional-effect-systems-in-rust/iteration2) error[E0308]: mismatched types --\u003e iteration2/src/lib.rs:146:17 | 145 | .fold(ToyIo::effect(|| Vec::new()), |acc, curr| { | -- | | | the expected closure | the found closure 146 | / IoExt::flat_map(acc, |x| { 147 | | (self.func)(curr).map(|y| { 148 | | let mut z = x; 149 | | z.push(y); 150 | | z 151 | | }) 152 | | }) | |__________________^ expected `ToyIo\u003c[closure@lib.rs:145:33]\u003e`, found `FlatMap",
  "wordCount" : "2040",
  "inLanguage": "en",
  "datePublished": "2023-05-29T19:21:34+09:00",
  "dateModified": "2023-05-29T19:21:34+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://blog.cro.sh/posts/demystifying-functional-effect-systems-in-rust-part-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Option::None",
    "logo": {
      "@type": "ImageObject",
      "url": "http://blog.cro.sh/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://blog.cro.sh/" accesskey="h" title="Option::None (Alt + H)">Option::None</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://blog.cro.sh/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Demystifying Functional Effect Systems in Rust (Part 1)
    </h1>
    <div class="post-meta"><span title='2023-05-29 19:21:34 +0900 KST'>May 29, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Effect system을 공부하던 중, <a href="https://medium.com/wix-engineering/demystifying-functional-effect-systems-in-scala-14419039a423">Demystifying Functional Effect Systems in Scala</a>라는 좋은 글을 접했다. Rust에서 effect system을 적용하면 어떤 모습이 될 지 궁금하여, 해당 글을 한국어로 간단히 요약하면서 Rust로 코드를 옮겨보았다.</p>
<blockquote>
<p>프로그래밍 언어 이론을 공부하는 초심자의 시선에서 작성했기 때문에 내용에 부정확한 점이나 오역이 있을 수 있습니다. 이메일 <a href="mailto:hyun@cro.sh">hyun@cro.sh</a> 로 연락 주시면 정정하겠습니다. 감사합니다.</p>
</blockquote>
<h1 id="1장-이펙트-생성하고-조합하기">1장: 이펙트 생성하고 조합하기<a hidden class="anchor" aria-hidden="true" href="#1장-이펙트-생성하고-조합하기">#</a></h1>
<p>이펙트는 일반적으로 IO 모나드의 개념에서 출발한다. IO 모나드는 인자 없는 함수를 감싸 효과(이펙트)를 (필요하면) 만들어내고 반환값을 생성해내는 객체<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>다. 모나드가 됨으로서 여러 개의 &lsquo;감싸진&rsquo; (혹은 일시정지된) 이펙트가 합성되어 이펙트들의 순차적 실행을 표현할 수 있게 된다.</p>
<p>참고로, 일반적인 모나드에 대한 설명은 이 글에서 다루지 않으나, 이러한 개념을 이해하는 것은 이 글을 따라가는 데 상당히 중요할 것이다.</p>
<p>기본적인 IO 모나드는 아마도 다음과 같은 trait으로 정의할 수 있을 텐데, <code>ToyIo::effect</code> 생성자(대개 <code>pure</code>라는 이름으로도 불려짐)를 통해 실존하는 &rsquo;toy&rsquo; 구현체를 생성할 수 있게 된다(아직 세부적인 구현은 이루어지지 않음).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> IoExt: <span style="color:#a6e22e">Io</span> <span style="color:#f92672">+</span> Sized {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">flat_map</span><span style="color:#f92672">&lt;</span>R: <span style="color:#a6e22e">Io</span>, F: FnOnce(Self::Success) -&gt; <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">FlatMap</span><span style="color:#f92672">&lt;</span>Self, F<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">&lt;</span>S, F: FnOnce(Self::Success) -&gt; <span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Map</span><span style="color:#f92672">&lt;</span>Self, F<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Io</span><span style="color:#f92672">&gt;</span> IoExt <span style="color:#66d9ef">for</span> T {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">flat_map</span><span style="color:#f92672">&lt;</span>R: <span style="color:#a6e22e">Io</span>, F: FnOnce(Self::Success) -&gt; <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">FlatMap</span><span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        FlatMap {
</span></span><span style="display:flex;"><span>            inner: <span style="color:#a6e22e">self</span>,
</span></span><span style="display:flex;"><span>            func: <span style="color:#a6e22e">f</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">&lt;</span>S, F: FnOnce(Self::Success) -&gt; <span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Map</span><span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Map {
</span></span><span style="display:flex;"><span>            inner: <span style="color:#a6e22e">self</span>,
</span></span><span style="display:flex;"><span>            func: <span style="color:#a6e22e">f</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ToyIo는 Io를 구현하는 어떠한 구조체 타입이다. 자세한 구현은 뒤에 나온다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(T);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, F: FnOnce() -&gt; <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> ToyIo<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">effect</span>(f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self(f)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<blockquote>
<p>실제 코드에서는 <code>flat_map</code>, <code>map</code>을 <code>IoExt</code> extension trait으로 구현하었고 뒤따라오는 코드들에서도 해당 구현을 기반으로 작성될 예정이다.</p>
</blockquote>
<p>이제 우리는 IO로 감싸진 이펙트들을 조합해 어떤 프로그램이든 만들어낼 수 있다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">program</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::io::{self, BufRead};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ToyIo::effect(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;what&#39;s your name?&#34;</span>))
</span></span><span style="display:flex;"><span>        .flat_map(<span style="color:#f92672">|</span>()<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>            ToyIo::effect(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> stdin <span style="color:#f92672">=</span> io::stdin().lock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>                stdin.read_line(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf).expect(<span style="color:#e6db74">&#34;cannot read&#34;</span>);
</span></span><span style="display:flex;"><span>                buf
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>name<span style="color:#f92672">|</span> ToyIo::effect(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;hello, </span><span style="color:#e6db74">{name}</span><span style="color:#e6db74">!&#34;</span>)))
</span></span><span style="display:flex;"><span>        .run();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>원문에서는 Scala의 for comprehension을 사용했으나 Rust에는 그러한 문법 설탕이 존재하지 않으므로 직접 desugaring하였다. 이는 Rust에서 이펙트 시스템을 적극적으로 채용하려면 proc-macro 등으로 문법을 확장하거나 컴파일러에서 문법 설탕을 지원해줘야 함을 함의한다.</p>
</blockquote>
<h2 id="toyio-구현"><code>ToyIo</code> 구현<a hidden class="anchor" aria-hidden="true" href="#toyio-구현">#</a></h2>
<p>이제 <code>ToyIo</code> 모나드를 본격적으로 구현해보자. <code>ToyIo</code>는 ZIO<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>의 API를 얼추 따르지만 typed error나 environment같은 기능은 단순함을 위해 제외되었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, F: FnOnce() -&gt; <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> ToyIo<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::Success {
</span></span><span style="display:flex;"><span>        todo!()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FlatMap</span><span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>    func: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Io</span>, R: <span style="color:#a6e22e">Io</span>, F: FnOnce(T::Success) -&gt; <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> FlatMap<span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> R::Success;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::Success {
</span></span><span style="display:flex;"><span>        todo!()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Map</span><span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>    func: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Io</span>, S, F: FnOnce(T::Success) -&gt; <span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> Map<span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> S;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::Success {
</span></span><span style="display:flex;"><span>        todo!()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<blockquote>
<p>코드가 원문에 비해 훨씬 장황한 이유는, 타입-레벨 프로그래밍과 정적 디스패치를 사용해 런타임 비용을 없애고자, 각 trait method의 리턴형을 독립된 타입으로 정의하였기 때문이다. 동적 디스패치로 처리한 코드는 그렇게 복잡하지 않다:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Io {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">flat_map</span><span style="color:#f92672">&lt;</span>R: <span style="color:#a6e22e">Io</span>, F: FnOnce(T) -&gt; <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">R</span>::Success;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">&lt;</span>S, F: FnOnce(T) -&gt; <span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">S</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(self) -&gt; <span style="color:#a6e22e">T</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> FnOnce() -&gt; <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> ToyIo<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">effect</span><span style="color:#f92672">&lt;</span>F: FnOnce() -&gt; <span style="color:#a6e22e">T</span> <span style="color:#f92672">+</span> &#39;static<span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self(Box::new(f))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> ToyIo<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> T; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">flat_map</span><span style="color:#f92672">&lt;</span>R: <span style="color:#a6e22e">Io</span>, F: FnOnce(T) -&gt; <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">R</span>::Success {
</span></span><span style="display:flex;"><span>        todo!()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">&lt;</span>S, F: FnOnce(T) -&gt; <span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">S</span> { todo!()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(self) -&gt; <span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>        todo!()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>또한, 원문에서는 <code>TIO.succeed()</code>를 활용해 <code>map</code>의 구현을 <code>flatMap</code>으로 넘기고 있지만, Rust에서는 그렇게 하면 익명 함수의 타입 파라미터를 만들어낼 수 없기 때문에 불가능하다. RPITIT(return-position-impl-trait-in-trait)이 안정화되지 않는 한 각각 구현하는 것이 최선이라고 판단하였다.</p>
</blockquote>
<p><code>ToyIo</code>와 <code>FlatMap</code>, <code>Map</code>은 이펙트가 어떻게 실행되어야 하는지를 정의한다. 이 정의는 가끔 &lsquo;대수&rsquo;로 불리기도 한다. (작성자 주: &lsquo;대수적 이펙트&rsquo;의 그 &lsquo;대수&rsquo;인 것으로 보인다.)</p>
<blockquote>
<p>엄밀히 원문의 Scala case class를 사용한 코드를 Rust로 옮기면 열거형으로 FlatMap과 Map을 표현했어야 하나, zero-cost를 강조하기 위해 각각을 구조체로 표현하고 타입 레벨 프로그래밍을 도입하였다.</p>
</blockquote>
<p>이제 이 ToyIo와 친구들의 실행 방법을 정의할 차례이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::error::Error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BoxError</span> <span style="color:#f92672">=</span> Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Error <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync <span style="color:#f92672">+</span> &#39;static<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Run: <span style="color:#a6e22e">Io</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, BoxError<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, F: FnOnce() -&gt; <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> Run <span style="color:#66d9ef">for</span> ToyIo<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, BoxError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Ok(self.<span style="color:#ae81ff">0</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Run</span>, R: <span style="color:#a6e22e">Run</span>, F: FnOnce(T::Success) -&gt; <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span> Run <span style="color:#66d9ef">for</span> FlatMap<span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, BoxError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        (self.func)(self.inner.eval()<span style="color:#f92672">?</span>).eval()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Run</span>, S, F: FnOnce(T::Success) -&gt; <span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span> Run <span style="color:#66d9ef">for</span> Map<span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, BoxError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Ok((self.func)(self.inner.eval()<span style="color:#f92672">?</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>엄밀히 따지면, 에러를 박싱함으로서 zero-cost에서 벗어났다고도 할 수 있다. 그러나 에러 처리 자체를 zero-cost로 구현하는 것에 집중하기보다는(필자가 생각하는 선에서는 완벽한 zero-cost 에러 처리를 타입 레벨 프로그래밍으로 구현할 수는 없을 것 같다) effect system을 구현하는 것에 집중하는 것이 옳다는 판단 하에 에러를 박싱하였다.</p>
</blockquote>
<p>이제 <code>ToyIo</code>를 실제로 사용해보자. 그러기 위해서는 <code>ToyIo</code>를 실행해줄 실행기가 필요하다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unsafe_run_sync</span><span style="color:#f92672">&lt;</span>R: <span style="color:#a6e22e">Run</span><span style="color:#f92672">&gt;</span>(r: <span style="color:#a6e22e">R</span>) -&gt; Result<span style="color:#f92672">&lt;</span>R::Success, Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Error <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync <span style="color:#f92672">+</span> &#39;static<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    r.eval()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sequence_effects</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> effect <span style="color:#f92672">=</span> ToyIo::effect(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;running first effect&#34;</span>))
</span></span><span style="display:flex;"><span>        .flat_map(<span style="color:#f92672">|</span>()<span style="color:#f92672">|</span> ToyIo::effect(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;running second effect&#34;</span>)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    unsafe_run_sync(effect).expect(<span style="color:#e6db74">&#34;cannot unsafe_run_sync&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>running first effect
</span></span><span style="display:flex;"><span>running second effect
</span></span></code></pre></div><blockquote>
<p>원문에서는 <code>unsafe_run_sync</code>이 <code>eval().unwrap()</code>을 수행하는 것에 가까우나 이는 idiomatic Rust에서 멀어지게 되므로 지양하였다.</p>
</blockquote>
<p>1장의 전체 코드는 <a href="https://github.com/cr0sh/demystifying-functional-effect-systems-in-rust/blob/master/iteration1/src/lib.rs">https://github.com/cr0sh/demystifying-functional-effect-systems-in-rust/blob/master/iteration1/src/lib.rs</a> 에 있다.</p>
<h1 id="2장-에러로부터-복구하기">2장: 에러로부터 복구하기<a hidden class="anchor" aria-hidden="true" href="#2장-에러로부터-복구하기">#</a></h1>
<p>에러 핸들링을 지원하기 위해, 어떻게 이펙트의 실패를 표현할 수 있을지 알아보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToyIoFail</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>(E);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> ToyIoFail<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fail</span>(e: <span style="color:#a6e22e">E</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self(e)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> ToyIoFail<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> Never; <span style="color:#75715e">// #[feature(never_type)] 이 안정화되면 `!`일 것이다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>E: <span style="color:#a6e22e">Error</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync <span style="color:#f92672">+</span> &#39;static<span style="color:#f92672">&gt;</span> Run <span style="color:#66d9ef">for</span> ToyIoFail<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, BoxError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Err(Box::new(self.<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Clone, Copy)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Never</span> {}
</span></span></code></pre></div><p>이제 실패한 이펙트의 복구 방법도 알아보자:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> IoExt: <span style="color:#a6e22e">Io</span> <span style="color:#f92672">+</span> Sized {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">recover</span><span style="color:#f92672">&lt;</span>U: <span style="color:#a6e22e">Io</span><span style="color:#f92672">&lt;</span>Success <span style="color:#f92672">=</span> Self::Success<span style="color:#f92672">&gt;</span>, F: FnOnce(BoxError) -&gt; <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>        self,
</span></span><span style="display:flex;"><span>        f: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">Recover</span><span style="color:#f92672">&lt;</span>Self, F<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Io</span><span style="color:#f92672">&gt;</span> IoExt <span style="color:#66d9ef">for</span> T {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">recover</span><span style="color:#f92672">&lt;</span>U: <span style="color:#a6e22e">Io</span><span style="color:#f92672">&lt;</span>Success <span style="color:#f92672">=</span> T::Success<span style="color:#f92672">&gt;</span>, F: FnOnce(BoxError) -&gt; <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>        self,
</span></span><span style="display:flex;"><span>        f: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">Recover</span><span style="color:#f92672">&lt;</span>Self, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Recover {
</span></span><span style="display:flex;"><span>            inner: <span style="color:#a6e22e">self</span>,
</span></span><span style="display:flex;"><span>            func: <span style="color:#a6e22e">f</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Recover</span><span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>    func: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, S: <span style="color:#a6e22e">Io</span><span style="color:#f92672">&lt;</span>Success <span style="color:#f92672">=</span> T<span style="color:#f92672">&gt;</span>, U: <span style="color:#a6e22e">Io</span><span style="color:#f92672">&lt;</span>Success <span style="color:#f92672">=</span> T<span style="color:#f92672">&gt;</span>, F: FnOnce(BoxError) -&gt; <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> Recover<span style="color:#f92672">&lt;</span>S, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, S: <span style="color:#a6e22e">Run</span><span style="color:#f92672">&lt;</span>Success <span style="color:#f92672">=</span> T<span style="color:#f92672">&gt;</span>, U: <span style="color:#a6e22e">Run</span><span style="color:#f92672">&lt;</span>Success <span style="color:#f92672">=</span> T<span style="color:#f92672">&gt;</span>, F: FnOnce(BoxError) -&gt; <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span> Run <span style="color:#66d9ef">for</span> Recover<span style="color:#f92672">&lt;</span>S, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, BoxError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.inner.eval() {
</span></span><span style="display:flex;"><span>            Ok(x) <span style="color:#f92672">=&gt;</span> Ok(x),
</span></span><span style="display:flex;"><span>            Err(e) <span style="color:#f92672">=&gt;</span> (self.func)(e).eval(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이제 실제로 이를 사용해 오류를 복구해보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{error::Error, fmt::Display};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">super</span>::<span style="color:#f92672">*</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">StrError</span>(<span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Display <span style="color:#66d9ef">for</span> StrError {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fmt</span>(<span style="color:#f92672">&amp;</span>self, f: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::fmt::Formatter<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">std</span>::fmt::Result {
</span></span><span style="display:flex;"><span>        write!(f, <span style="color:#e6db74">&#34;{}&#34;</span>, self.<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Error <span style="color:#66d9ef">for</span> StrError {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fail_and_recover</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> effect <span style="color:#f92672">=</span> ToyIo::effect(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;running first effect&#34;</span>))
</span></span><span style="display:flex;"><span>        .flat_map(<span style="color:#f92672">|</span>()<span style="color:#f92672">|</span> ToyIoFail::fail(StrError(<span style="color:#e6db74">&#34;some error&#34;</span>)))
</span></span><span style="display:flex;"><span>        .flat_map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> ToyIo::effect(<span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;second effect - will not run&#34;</span>)))
</span></span><span style="display:flex;"><span>        .recover(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> ToyIo::effect(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> println!(<span style="color:#e6db74">&#34;recovered from failure: </span><span style="color:#e6db74">{e}</span><span style="color:#e6db74">&#34;</span>)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    unsafe_run_sync(effect).expect(<span style="color:#e6db74">&#34;cannot execute&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>running first effect
</span></span><span style="display:flex;"><span>recovered from failure: some error
</span></span></code></pre></div><p>여기까지만 해도 충분히 강력하지만, 우리의 <code>ToyIo</code> 예제는 두 가지 문제점이 있다:</p>
<ul>
<li>비동기를 지원하지 않는다.</li>
<li>Stack-safe하지 않다.</li>
</ul>
<p>두 번쩨 포인트를 짚어보자면, 우리의 구현은 재귀에 의존하기 때문에 타입의 깊이가 깊어지면 그만큼 재귀의 깊이도 깊어진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToyIoForEach</span><span style="color:#f92672">&lt;</span>I, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    it: <span style="color:#a6e22e">I</span>,
</span></span><span style="display:flex;"><span>    func: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>I, F<span style="color:#f92672">&gt;</span> ToyIoForEach<span style="color:#f92672">&lt;</span>I, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">for_each</span>(it: <span style="color:#a6e22e">I</span>, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self { it, func: <span style="color:#a6e22e">f</span> }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>Item, I: Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> Item<span style="color:#f92672">&gt;</span>, R: <span style="color:#a6e22e">Io</span>, F: FnMut(Item) -&gt; <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> ToyIoForEach<span style="color:#f92672">&lt;</span>I, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> Vec<span style="color:#f92672">&lt;</span>R::Success<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, BoxError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.it
</span></span><span style="display:flex;"><span>            .fold(ToyIo::effect(<span style="color:#f92672">||</span> Vec::new()), <span style="color:#f92672">|</span>acc, curr<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// mismatched types
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                IoExt::flat_map(acc, <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                    (self.func)(curr).map(<span style="color:#f92672">|</span>y<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> z <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>                        z.push(y);
</span></span><span style="display:flex;"><span>                        z
</span></span><span style="display:flex;"><span>                    })
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>            .eval()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>    Checking iteration2 v0.1.0 (/Users/namjh/dev/personal/demystifying-functional-effect-systems-in-rust/iteration2)
</span></span><span style="display:flex;"><span>error[E0308]: mismatched types
</span></span><span style="display:flex;"><span>   --&gt; iteration2/src/lib.rs:146:17
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>145 |               .fold(ToyIo::effect(|| Vec::new()), |acc, curr| {
</span></span><span style="display:flex;"><span>    |                                   --
</span></span><span style="display:flex;"><span>    |                                   |
</span></span><span style="display:flex;"><span>    |                                   the expected closure
</span></span><span style="display:flex;"><span>    |                                   the found closure
</span></span><span style="display:flex;"><span>146 | /                 IoExt::flat_map(acc, |x| {
</span></span><span style="display:flex;"><span>147 | |                     (self.func)(curr).map(|y| {
</span></span><span style="display:flex;"><span>148 | |                         let mut z = x;
</span></span><span style="display:flex;"><span>149 | |                         z.push(y);
</span></span><span style="display:flex;"><span>150 | |                         z
</span></span><span style="display:flex;"><span>151 | |                     })
</span></span><span style="display:flex;"><span>152 | |                 })
</span></span><span style="display:flex;"><span>    | |__________________^ expected `ToyIo&lt;[closure@lib.rs:145:33]&gt;`, found `FlatMap&lt;ToyIo&lt;[closure@lib.rs:145:33]&gt;, ...&gt;`
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>    = note: expected struct `ToyIo&lt;_&gt;`
</span></span><span style="display:flex;"><span>               found struct `FlatMap&lt;ToyIo&lt;_&gt;, [closure@iteration2/src/lib.rs:146:38: 146:41]&gt;`
</span></span></code></pre></div><p>어라?</p>
<p>생각해보니 스칼라는 동적 디스패치를 vtable로 구현하는 언어고, 그렇기 때문에 <code>flatMap</code>이 n번 중첩된 객체와 m번 중첩된 객체를 <code>TIO</code>라는 같은 trait으로 다룰 수 있다.  Rust의 문법을 빌리면, <code>ToyIo&lt;_&gt;</code>와 <code>FlatMap&lt;ToyIo&lt;_&gt;, _&gt;</code>, <code>FlatMap&lt;FlatMap&lt;...FlatMap&lt;ToyIo&lt;_&gt;, _&gt;..._&gt; _&gt;</code>이 모두 한 변수에 들어갈 수 있어야 하는 것이다. 그런데 내가 구현한 방식은 타입 레벨 프로그래밍을 사용해 정적 디스패치만을 고수하였으므로 이렇게 런타임에 디스패치를 할 수가 없다!</p>
<p>😱</p>
<p>해법을 찾아보자. 스칼라의 방법을 그대로 모사해서 <code>Box</code>로 type erasure을 구현할 수 있다. 원문의 코드를 가져오면 <a href="https://github.com/dkarlinsky/tio/blob/1f4f7b037b1845ea4b86fe44b640668a8f049a2c/src/main/scala/tio/TIO.scala#L13-L18">다음</a>과 같다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#75715e">// Initial algebra
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Effect</span><span style="color:#f92672">[</span><span style="color:#66d9ef">+A</span><span style="color:#f92672">](</span>a<span style="color:#66d9ef">:</span> <span style="color:#f92672">()</span> <span style="color:#f92672">=&gt;</span> A<span style="color:#f92672">)</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fail</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>e<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Throwable</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Effect combinators
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FlatMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span>, <span style="color:#66d9ef">B</span><span style="color:#f92672">](</span>tio<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> f<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">B</span><span style="color:#f92672">])</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">B</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Recover</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>tio<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> f<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Throwable</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">])</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">TIO</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>이를 Rust enum으로 모델링해보자. Case class의 타입 파라미터가 모두 같지 않아서 불가능할 것 같지만, <code>extends TIO[_]</code>에서 <code>_</code>에 해당하는 부분을 기준으로 잡아 <code>T</code>로 통일하고 나머지 타입 파라미터를 박싱으로 지우면 가능하다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// A &#39;toy&#39; IO effect that can either succeed with `T` or fail with `E`.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Effect(Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> FnOnce() -&gt; Result<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;&gt;</span>),
</span></span><span style="display:flex;"><span>    Fail(E),
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Should be boxed to &#39;erase&#39; the return type of the inner effect
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    FlatMap(Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> FlatMap<span style="color:#f92672">&lt;</span>Success <span style="color:#f92672">=</span> T, Error <span style="color:#f92672">=</span> E<span style="color:#f92672">&gt;&gt;</span>),
</span></span><span style="display:flex;"><span>    Recover(Box<span style="color:#f92672">&lt;</span>Self<span style="color:#f92672">&gt;</span>, Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> FnOnce(E) -&gt; <span style="color:#a6e22e">Self</span><span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> FlatMap {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Error</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mapped</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>Self::Success, Self::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FlatMapImpl</span><span style="color:#f92672">&lt;</span>T, U, E, F: FnOnce(T) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>U, E<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    func: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>enum으로 구현하는 김에, 에러 타입을 박싱하지 않도록 해 최대한 컴파일 타임에 에러를 식별할 수 있도록 해 보았다. (아마도 실용적인 면에서 <code>map_err</code> 같은 메서드가 필요할 것이다.)</p>
</blockquote>
<p>이제 Scala 구현을 참조해 이펙트 생성자와 친구 메서드들을 구현해주면 다음과 같다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: &#39;static, E: &#39;static<span style="color:#f92672">&gt;</span> ToyIo<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">succeed</span>(x: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self::Effect(Box::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> Ok(x)))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">effect</span>(f: <span style="color:#a6e22e">impl</span> FnOnce() -&gt; <span style="color:#a6e22e">T</span> <span style="color:#f92672">+</span> &#39;static) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self::Effect(Box::new(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> Ok(f())))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fail</span>(err: <span style="color:#a6e22e">E</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self::Fail(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">&lt;</span>U: &#39;static<span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">impl</span> FnOnce(T) -&gt; <span style="color:#a6e22e">U</span> <span style="color:#f92672">+</span> &#39;static) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>U, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        ToyIo::FlatMap(Box::new(Some(FlatMapImpl {
</span></span><span style="display:flex;"><span>            inner: <span style="color:#a6e22e">self</span>,
</span></span><span style="display:flex;"><span>            func: <span style="color:#a6e22e">move</span> <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> ToyIo::succeed(f(x)),
</span></span><span style="display:flex;"><span>        })))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">recover</span>(self, f: <span style="color:#a6e22e">impl</span> FnOnce(E) -&gt; <span style="color:#a6e22e">Self</span> <span style="color:#f92672">+</span> &#39;static) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self::Recover(Box::new(self), Box::new(f))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>물론, <code>(ToyIo&lt;T, E&gt;, T -&gt; ToyIo&lt;U, E&gt;)</code>에서 <code>T</code>를 지워 <code>ToyIo&lt;U, E&gt;</code>의 모양새만 남기는 <code>FlatMap</code> trait의 구현도 잊어서는 안 된다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, U, E, F: FnOnce(T) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>U, E<span style="color:#f92672">&gt;&gt;</span> FlatMap <span style="color:#66d9ef">for</span> Option<span style="color:#f92672">&lt;</span>FlatMapImpl<span style="color:#f92672">&lt;</span>T, U, E, F<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> U;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Error</span> <span style="color:#f92672">=</span> E;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mapped</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>Self::Success, Self::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> this <span style="color:#f92672">=</span> self.take().unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> this.inner.eval().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> (this.func)(x)) {
</span></span><span style="display:flex;"><span>            Ok(eff) <span style="color:#f92672">=&gt;</span> eff,
</span></span><span style="display:flex;"><span>            Err(e) <span style="color:#f92672">=&gt;</span> ToyIo::Fail(e),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이제 <code>Option&lt;FlatMapImpl&lt;T, U, E, F&gt;&gt;</code>를 <code>Box&lt;dyn FlatMap&lt;U, E&gt;</code>로 박싱해 <code>T</code>를 지울 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: &#39;static, E: &#39;static<span style="color:#f92672">&gt;</span> ToyIo<span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">flat_map</span><span style="color:#f92672">&lt;</span>U: &#39;static<span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">impl</span> FnOnce(T) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>U, E<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;static) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>U, E<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        ToyIo::FlatMap(Box::new(Some(FlatMapImpl {
</span></span><span style="display:flex;"><span>            inner: <span style="color:#a6e22e">self</span>,
</span></span><span style="display:flex;"><span>            func: <span style="color:#a6e22e">f</span>,
</span></span><span style="display:flex;"><span>        })))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>다시 본론으로 돌아와서 <code>ForEach</code>를 구현해보자. 이제는 <code>ToyIo::flat_map</code>이 <code>ToyIo</code>를 내뱉으므로 <code>flat_map</code>을 임의의 개수만큼 중첩시킬 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ForEach</span><span style="color:#f92672">&lt;</span>I, F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    it: <span style="color:#a6e22e">I</span>,
</span></span><span style="display:flex;"><span>    func: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        Item: &#39;static,
</span></span><span style="display:flex;"><span>        I: Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> Item<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        T: &#39;static,
</span></span><span style="display:flex;"><span>        E: &#39;static,
</span></span><span style="display:flex;"><span>        F: FnOnce(Item) -&gt; <span style="color:#a6e22e">ToyIo</span><span style="color:#f92672">&lt;</span>T, E<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;</span> Io <span style="color:#66d9ef">for</span> ForEach<span style="color:#f92672">&lt;</span>I, F<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Success</span> <span style="color:#f92672">=</span> Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Error</span> <span style="color:#f92672">=</span> E;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(self) -&gt; Result<span style="color:#f92672">&lt;</span>Self::Success, Self::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.it
</span></span><span style="display:flex;"><span>            .fold(ToyIo::effect(<span style="color:#f92672">||</span> Vec::new()), <span style="color:#f92672">|</span>acc, curr<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> func <span style="color:#f92672">=</span> self.func.clone();
</span></span><span style="display:flex;"><span>                acc.flat_map(<span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                    (func)(curr).map(<span style="color:#f92672">|</span>y<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> z <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>                        z.push(y);
</span></span><span style="display:flex;"><span>                        z
</span></span><span style="display:flex;"><span>                    })
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>            .eval()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>그리고 10만번 순회하는 <code>for_each</code>를 실행하면&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">for_each</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> effect <span style="color:#f92672">=</span> ToyIo::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span>, Infallible<span style="color:#f92672">&gt;</span>::for_each(<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">100000</span>, <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        ToyIo::<span style="color:#f92672">&lt;</span>_, Infallible<span style="color:#f92672">&gt;</span>::effect(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{x}</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>            x
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    unsafe_run_sync(effect).expect(<span style="color:#e6db74">&#34;cannot execute&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>thread &#39;test::for_each&#39; has overflowed its stack
</span></span><span style="display:flex;"><span>fatal runtime error: stack overflow
</span></span><span style="display:flex;"><span>error: test failed, to rerun pass `--lib`
</span></span></code></pre></div><p>너무 많이 중첩된 <code>flat_map</code>을 해석하던 중 스택 오버플로우가 발생하는 모습을 볼 수 있다.</p>
<p>2장의 전체 코드는 <a href="https://github.com/cr0sh/demystifying-functional-effect-systems-in-rust/blob/master/iteration2/src/lib.rs">https://github.com/cr0sh/demystifying-functional-effect-systems-in-rust/blob/master/iteration2/src/lib.rs</a> 에 있다.</p>
<p>3장과 4장은 [part 2](TBD)에서 이어집니다.</p>
<h1 id="각주">각주<a hidden class="anchor" aria-hidden="true" href="#각주">#</a></h1>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>원문은 &lsquo;construct&rsquo;다.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>원문의 Scala 코드에 따르면 <code>Io&lt;T&gt;</code> trait이 타입 파라미터 <code>T</code>에 대해 covariant해야 하나(<code>trait IO[+A]</code>), Rust에서는 trait에서 variance를 표현할 방법이 없다. 상속 기반 서브타이핑이 Rust에서는 사용되지 않기 때문에 invariance가 큰 문제를 일으키지 않는다고 판단했다.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Scala에서 유명한 Effect system 라이브러리다.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>원문에서는 이 이후로 <code>.run()</code>을 사용하는 예시가 나오지 않으므로 추후의 구현에서 <code>run</code> 메서드는 생략하도록 한다. 참고로, 타입 시스템의 한계로 인해 Rust에서 이 <code>.run()</code>을 구현하려 하면 <code>&lt;FlatMap as Io&gt;::run</code>의 구현을 만들어내는 것이 불가능하다.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>© 2019-2023 Nam Junghyun</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "152863abaa9948f9bb84e53ef4204e47"}'></script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
